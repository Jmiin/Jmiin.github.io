{"meta":{"title":"JmiinBlog","subtitle":"","description":"靡不有初，鲜克有终。","author":"Jmiin","url":"http://jmiin.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2020-09-03T09:42:57.516Z","updated":"2020-09-03T09:42:57.516Z","comments":true,"path":"tags/index.html","permalink":"http://jmiin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-03T08:54:43.931Z","updated":"2020-09-03T08:54:43.931Z","comments":true,"path":"404.html","permalink":"http://jmiin.github.io/404.html","excerpt":"","text":"12345678910cover: truerobots: noindex,nofollowsitemap: falselayout: docsseo_title: 404 Not Foundbottom_meta: falsesidebar: []valine: path: &#x2F;404.html placeholder: 请留言告诉我您要访问哪个页面找不到了 404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-09-03T09:02:24.631Z","updated":"2020-09-03T09:02:24.631Z","comments":true,"path":"about/index.html","permalink":"http://jmiin.github.io/about/index.html","excerpt":"","text":"年少轻狂的好日子，一懂事就结束。"},{"title":"所有分类","date":"2020-09-03T09:42:48.290Z","updated":"2020-09-03T09:42:48.290Z","comments":true,"path":"categories/index.html","permalink":"http://jmiin.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-03T09:42:15.283Z","updated":"2020-09-03T09:42:15.283Z","comments":true,"path":"friends/index.html","permalink":"http://jmiin.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"线程实现及创建方式","slug":"2020-09-05-线程实现及创建方式","date":"2020-09-04T16:00:00.000Z","updated":"2020-09-04T02:51:55.490Z","comments":true,"path":"2020/09/05/2020-09-05-线程实现及创建方式/","link":"","permalink":"http://jmiin.github.io/2020/09/05/2020-09-05-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/","excerpt":"","text":"线程的基本状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public enum State &#123; /** * Thread state for a thread which has not yet started. * 初始状态，线程被构建，但是还没有调用start()方法 */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. * 运行状态，Java线程将操作系统中的就绪和运行状态笼统的称作：运行中 * */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. * 阻塞状态，表示线程阻塞于锁 */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. * 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定的动作 *(通知或中断) */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; * 超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的 * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. * 终止状态，表示当前线程已经执行完毕 */ TERMINATED;&#125; 线程并不是始终固定于某一个状态而是随着代码的执行在不同状态之间进行切换的。 线程的创建方式继承Thread类实现Runnable接口ExecutorService、Callable&lt;&gt;基于线程池的方式","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程实现及创建方式","slug":"Java基础/多线程/线程实现及创建方式","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"进程与线程","slug":"2020-09-05-进程与线程","date":"2020-09-04T16:00:00.000Z","updated":"2020-09-04T02:30:53.945Z","comments":true,"path":"2020/09/05/2020-09-05-进程与线程/","link":"","permalink":"http://jmiin.github.io/2020/09/05/2020-09-05-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程与线程基本概念 一切都是为了提高系统资源利用率，提高系统吞吐量而生。 背景最初的时候的计算机完全由用户输入的指令控制执行，当用户停止时，计算机也会停止。这样效率及其低下。尽管后面出来的批处理系统可以将指令形成一套连续的流程对计算机进行控制，但是运行方式 仍然是串行的，内存中永远都是只有一个程序在运行，所以批处理效率也并不高。 内存完全是可以存在多个程序同时进行的。于是，进程由此诞生，进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的，各个进程之间互相不干扰。同时进程保存着程序每一个时刻运行的状态。 此时，CPU采用时间片轮询的方式运行进程：如果时间片结束进程还没有执行完毕，则暂停这个进程的运行，并且把CPU分配给其他的进程，这个过程就叫做上下文切换。 它的出现让操作系统的并发成为了可能，虽然并发从宏观上看有多个任务在执⾏，但在事实上，对于单核CPU来说，任意具体时刻都只有⼀个任务在占⽤CPU资源。 线程的提出进程的出现并不能让人们满足，如果⼀个进程有多个⼦任务时，只能逐个得执行这些子任务，很影响效率。为了同时让这些子任务同时执行，于是线程的提出变成了理所当然，每个线程负责一个单独的子任务。 线程与进程相似，但线程是⼀个⽐进程更小的执⾏单位。⼀个进程在其执⾏的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同⼀块内存空间和⼀组系统资源，所以系统在产生⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程小得多，也正因为如此，线程也被称为轻量级进程。 多线程实现并发的好处1.进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。2.进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。 两者之间的区别进程是一个独立的运行环境，而线程是在进程中执行的一个任务。它们本质的区别是是否单独占有内存地址空间及其它系统资源： 1.进程单独占由一定的内存地址空间，它们之间是存在内存隔离，数据是分开的，数据共享复杂但是同步简单各个进程之间互不干扰；而线程共享所属进程占用的内存地址空间和资源，数据共享简单，但是同步复杂。 2.进程单独占有一定的内存地址空间，一个进程出现问题不会影响其它进程，不影响主程序的稳定性，可靠性高；一个线程奔溃可能影响整个程序的稳定性，可靠性低。 3.进程单独占有一定的内存地址空间，进程的创建和销毁不仅仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销大；线程只需要保存寄存器和栈信息，开销小。 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"进程与线程","slug":"Java基础/多线程/进程与线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java常用关键字","slug":"2020-09-03-java常用关键字","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-03T07:04:33.921Z","comments":true,"path":"2020/09/03/2020-09-03-java常用关键字/","link":"","permalink":"http://jmiin.github.io/2020/09/03/2020-09-03-java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"​ final 关键字final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； final修饰的方法不能被重写； final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static 关键字static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this 关键字this关键字用于引用类的当前实例。 例如： 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println(&quot;Total employees: &quot; + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在上面的示例中，this关键字用于两个地方： this.employees.length：访问类Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。 此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。 super 关键字super关键字用于从子类访问父类的变量和方法。 例如： 1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 使用 this 和 super 要注意的问题： 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 static 关键字详解static 关键字主要有以下四种使用场景 修饰成员变量和成员方法 静态代码块 修饰类(只能修饰内部类) 静态导包(用来导入类中的静态资源，1.5之后的新特性) 修饰成员变量和成员方法(常用)被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。 调用格式： 类名.静态变量名 类名.静态方法名() 如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。 测试方法： 1234567891011121314151617181920public class StaticBean &#123; String name; //静态变量 static int age; public StaticBean(String name) &#123; this.name = name; &#125; //静态方法 static void SayHello() &#123; System.out.println(&quot;Hello i am java&quot;); &#125; @Override public String toString() &#123; return &quot;StaticBean&#123;&quot;+ &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;&#125;&quot;; &#125;&#125; 1234567891011121314public class StaticDemo &#123; public static void main(String[] args) &#123; StaticBean staticBean = new StaticBean(&quot;1&quot;); StaticBean staticBean2 = new StaticBean(&quot;2&quot;); StaticBean staticBean3 = new StaticBean(&quot;3&quot;); StaticBean staticBean4 = new StaticBean(&quot;4&quot;); StaticBean.age = 33; System.out.println(staticBean + &quot; &quot; + staticBean2 + &quot; &quot; + staticBean3 + &quot; &quot; + staticBean4); //StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125; StaticBean.SayHello();//Hello i am java &#125;&#125; 静态代码块静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 123static &#123; 语句体; &#125; 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问. 静态内部类静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非static成员变量和方法。 Example（静态内部类实现单例模式） 123456789101112131415public class Singleton &#123; //声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 静态导包格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 123456789101112131415 //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用 //如果只想导入单一某个静态方法，只需要将换成对应的方法名即可 import static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果 public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; 补充内容静态方法与非静态方法静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 Example 12345678910111213141516class Foo &#123; int i; public Foo(int i) &#123; this.i = i; &#125; public static String method1() &#123; return &quot;An example string that doesn&#x27;t depend on i (an instance variable)&quot;; &#125; public int method2() &#123; return this.i + 1; //Depends on i &#125;&#125; 你可以像这样调用静态方法：Foo.method1()。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：Foo bar = new Foo(1);bar.method2(); 总结： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 static&#123;&#125;静态代码块与&#123;&#125;非静态代码块(构造代码块) 相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 修正 issue #677：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 Class.forName(&quot;ClassDemo&quot;)创建 Class 对象的时候也会执行。 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. Example： 12345678910111213141516171819202122232425262728public class Test &#123; public Test() &#123; System.out.print(&quot;默认构造方法！--&quot;); &#125; //非静态代码块 &#123; System.out.print(&quot;非静态代码块！--&quot;); &#125; //静态代码块 static &#123; System.out.print(&quot;静态代码块！--&quot;); &#125; private static void test() &#123; System.out.print(&quot;静态方法中的内容! --&quot;); &#123; System.out.print(&quot;静态方法中的代码块！--&quot;); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); Test.test();//静态代码块！--静态方法中的内容! --静态方法中的代码块！-- &#125;&#125; 上述代码输出： 1静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test.test(); 时输出： 1静态代码块！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test test = new Test(); 时输出： 1静态代码块！--非静态代码块！--默认构造方法！-- 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java常用关键字","slug":"Java常用关键字","permalink":"http://jmiin.github.io/tags/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"集合概览","slug":"2020-09-01-集合","date":"2020-08-31T16:00:00.000Z","updated":"2020-09-03T07:04:25.169Z","comments":true,"path":"2020/09/01/2020-09-01-集合/","link":"","permalink":"http://jmiin.github.io/2020/09/01/2020-09-01-%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java集合","slug":"Java基础/Java集合","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://jmiin.github.io/tags/Java%E9%9B%86%E5%90%88/"}]},{"title":"生活很苦，人生不苦!","slug":"2020-06-16-重新启程","date":"2020-06-15T16:00:00.000Z","updated":"2020-09-03T07:10:53.432Z","comments":true,"path":"2020/06/16/2020-06-16-重新启程/","link":"","permalink":"http://jmiin.github.io/2020/06/16/2020-06-16-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B/","excerpt":"","text":"1234567891011121314151617181920生活就像一面镜子你赠予它微笑，它回馈你美貌 你充斥着怒气，它回馈你丑陋当生活像一首歌那样轻快流畅时笑颜常开乃易事而在面对挫折时仍能乐观希望就像灿烂的阳光带着坚定的信念突破重重云层","categories":[{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Mysql简笔","slug":"2017-10-24-Mysql基本使用方法","date":"2017-10-23T16:00:00.000Z","updated":"2020-09-03T07:04:00.293Z","comments":true,"path":"2017/10/24/2017-10-24-Mysql基本使用方法/","link":"","permalink":"http://jmiin.github.io/2017/10/24/2017-10-24-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"启动服务 net start mysql net stop mysql ​ 进入mysql 输入用户名密码。 mysql -u 用户名 -p 如：mysql -u root -p 效果如下： 查看基本命令 每条命令结束后一定要加分号 1.show databases; 查看数据库 2.use 数据库; 选择数据库并使用它 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。 如： 3.show tables; 查看use的数据库的tables（表）; 我这里有下面3个表： 4.select * from 表名; 查看某个表 5.show columns from 表名; 查看某个表中所有字段 以上几个命令是必须掌握的查看命令 SQL语句对MySQL的操作 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。库中有3个表各个表的数据如下： 基本表的定义、删除、与修（略） sql基本了解(注：sql语言不区分大小写） SQL语句之数据查询 基本结构如下：SELECT …FROM …WHERE … 一、 单表查询 1.查询全体学生的学号与姓名。 2.查询出生年月日。 3.消除取值重复的行 关键词distinct 4.聚集函数 where子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having子句。 SQL语句之数据更新一、插入数据 123INSERTINTO &lt;表名&gt; (&lt;属性列1&gt;,&lt;属性列2&gt;,...)VALUES (&#39;常量1&#39;,&#39;常量2&#39;,...) 推荐 如果想更好的了解推荐以下视频 与MySQL的零距离接触","categories":[{"name":"数据库","slug":"数据库","permalink":"http://jmiin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"}]},{"title":"动态规划","slug":"2017-10-24-动态规划","date":"2017-10-23T16:00:00.000Z","updated":"2020-09-04T01:44:20.424Z","comments":true,"path":"2017/10/24/2017-10-24-动态规划/","link":"","permalink":"http://jmiin.github.io/2017/10/24/2017-10-24-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"什么是动态规划（DP）？ DP起源于运筹学，是求解决策过程最优化的数学方法，它一种是将多阶段过程转化为一系列单阶段问题，再利用各阶段之间的关系，逐个求解的方法。即动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。 动态规划干什么用？ 求解决策过程最优化。因此动态规划算法通常用于求解具有某种最优性质的问题。 通常可按以下4个步骤设计： 找出最优解的性质，并刻画其结构特征。 递归地定义最优值。 以自底向上的方式计算出最优解。 根据计算最优值时得到的信息，构造最优解。 动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。 如： 线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等； 区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等； 树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等； 背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶 等； 经典例题01背包问题 问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 如：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 本题特点是：每种物品仅有一件，可以选择放或不放。 F[i，j]表示在前i个物品中能够装入容量为j的背包中的最大价值。同时设v[i]、w[i]分别为第i个物品的价值和重量，v为背包的容量。 其状态转移方程便是： F[i, v] = maxf&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125; 二维0-1背包问题 给定n种物品和一个背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为c，容积为d。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品只有两个选择：装入或不装入，且不能重复装入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class twobage &#123; public static int maxx(int a, int b) &#123; if (a &gt;= b) return a; else return b; &#125; public static void main(String[] args) &#123; int[] weight = &#123;5,3,8 &#125;; // 物品重量 int[] val = &#123; 7,8,9 &#125;; // 物品价值 int[] b = &#123; 4,6,2 &#125;; int z = 30; // 背包容积 int p, q, i, m = 10; // 背包容量 int n = val.length; // 物品个数 int[][][] f = new int[n + 1][m + 1][z + 1]; // f[i][x][y]表示只允许装前i种物品，背包总重不超过x,物品总体积不超过y时，背包最大价值 int[] path = new int[n + 1]; //下标加1对应物品下标，其值为0代表不放，为1代表放 for (i = 0; i &lt;= n; i++) f[i][0][0] = 0; for (p = 0; p &lt;= m; p++) for (q = 0; q &lt;= z; q++) f[0][p][q] = 0; for (i = 1; i &lt;= n; i++) for (p = 1; p &lt;= m; p++) for (q = 1; q &lt;= z; q++) &#123; if (p &lt; weight[i - 1] || q &lt; b[i - 1]) &#123; f[i][p][q] = f[i - 1][p][q]; &#125;else &#123; f[i][p][q] = maxx(f[i - 1][p][q], f[i - 1][p - weight[i - 1]][q - b[i - 1]] + val[i - 1]); &#125; &#125; p = m; q = z; for (i = n; i &gt;= 1; i--) &#123; if (f[i][p][q] &gt; f[i - 1][p][q]) &#123; path[i] = 1; p = p - weight[i-1]; q = q - b[i-1]; &#125; else path[i] = 0; &#125; System.out.print(&quot;path值：&quot;); for (i = 1; i &lt;= n; i++) System.out.print(path[i] + &quot; &quot;); System.out.println(); System.out.print(&quot;放入的物品为：&quot;); for (i = 1; i &lt;= n; i++) if(path[i]==1) System.out.print(i-1+&quot;号 &quot;); System.out.println(); int r = 0; for (i = 1; i &lt;= n; i++) &#123; if (path[i] == 1) r += val[i - 1]; else r += 0; &#125; System.out.print(&quot;最大价值为：&quot;+r); &#125;&#125; 更多背包问题可以参考背包九讲 动态规划算法的基本要素1. 最优子结构2. 重叠子问题3. 边界4. 子问题独立5. 备忘录方法这里举个简单的例题：动态规划入门-数字三角形 Description 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得 路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //三角形行数。下面是三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 ​ Sample Output 30 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;public class triangle &#123;/* 测试数据：573 88 1 02 7 4 44 5 2 6 5 */ private static int max(int a, int b) &#123; if(a&gt;b) return a; else return b; &#125; public static void main(String[] args) &#123; System.out.print(&quot;请输入行数：&quot;); Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[][] a=new int[n+2][n+2]; int[][] path=new int[n+2][n+2]; int pmax=0; for(int i=0;i&lt;n+2;i++) &#123; a[i][i]=0; &#125; for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt;i;j++) &#123; a[i][j]=(int)sc.nextInt(); &#125; &#125; //输出测试数组 /*for(int i=0;i&lt;=n+1;i++) &#123; for(int j=0;j&lt;i+1;j++) &#123; System.out.print(a[i][j]+&quot; &quot;); &#125;System.out.println(); &#125;*/ for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; path[i][j]=max(path[i-1][j],path[i-1][j-1])+a[i][j]; &#125; &#125; //输出子问题值 for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; System.out.print(path[i][j]+&quot; &quot;); if (pmax &lt; path[i][j]) &#123; pmax = path[i][j];//算出最大值 &#125; &#125; System.out.println(); &#125; System.out.println(&quot;最大值为：&quot;+pmax); &#125; &#125; 更多感悟，如果还有下次，再见~","categories":[{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}]},{"title":"单片机","slug":"2017-10-21-T2定时器","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:36.202Z","comments":true,"path":"2017/10/21/2017-10-21-T2定时器/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-T2%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"实验三思考题： 若系统时钟频率为12MHz，编写软件实现：按一下K键，产生一次外部中断1中断信号，启动T2定时，使P1.1输出周期为2秒的方波。 定时器T2,reg52.h没有T2MOD寄存器,regx55.h有T2MOD寄存器而且sbit已经定义。因此头文件用reg55.h。 参考代码:123456789101112131415161718192021222324252627#include &lt;regx55.h&gt;#define uint unsigned int#define uchar unsigned intsbit P11&#x3D;P1^1;uchar num&#x3D;0;void main()&#123; T2MOD&#x3D;0x00; TH2&#x3D;(65536-50000)&#x2F;256; TL2&#x3D;(65536-50000)%256; RCAP2H&#x3D;(65536-50000)&#x2F;256; RCAP2L&#x3D;(65536-50000)%256; IE&#x3D;0xa4; while(1)&#123; if(TF2)&#123; num++; TF2&#x3D;0; &#125; if(num&#x3D;&#x3D;20)&#123; P11&#x3D;~P11; num&#x3D;0; &#125; &#125;&#125;void INTer1() interrupt 2&#123; TR2&#x3D;1;&#125; 因为简单，所以没有注释。 运行结果： 代码工程及仿真","categories":[{"name":"大学时光","slug":"大学时光","permalink":"http://jmiin.github.io/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"递归的时间复杂度","slug":"2017-10-21-递归树","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:48.324Z","comments":true,"path":"2017/10/21/2017-10-21-递归树/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-%E9%80%92%E5%BD%92%E6%A0%91/","excerpt":"","text":"Master定理 有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的： 设常数a &gt;= 1，b &gt; 1，f(n)为函数，T(n)为非负整数，T(n) = a T(n / b) + f(n)，则有： 递归树没事间写QAQ………","categories":[{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}]},{"title":"Jekyll","slug":"2017-10-21-jekyll","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:23.146Z","comments":true,"path":"2017/10/21/2017-10-21-jekyll/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-jekyll/","excerpt":"","text":"Jekyll Jekyll网站的目录结构。 . ├── _config.yml ├── _data | └── members.yml ├── _drafts | ├── begin-with-the-crazy-ideas.md | └── on-simplicity-in-technology.md ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | └── post.html ├── _posts | ├── 2007-10-29-why-every-programmer-should-play-nethack.md | └── 2009-04-26-barcamp-boston-4-roundup.md ├── _sass | ├── _base.scss | └── _layout.scss ├── _site ├── .jekyll-metadata └── index.html # can also be an &#39;index.md&#39; with valid YAML Frontmatter test2 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 原文链接","categories":[{"name":"暂未分类","slug":"暂未分类","permalink":"http://jmiin.github.io/categories/%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}]},{"title":"假如生活欺骗了你","slug":"2017-10-20-假如生活欺骗了你","date":"2017-10-19T16:00:00.000Z","updated":"2020-09-03T07:02:59.934Z","comments":true,"path":"2017/10/20/2017-10-20-假如生活欺骗了你/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/","excerpt":"","text":"假如生活欺骗了你 《假如生活欺骗了你》是俄国诗人普希金于1825年流放南俄敖德萨同当地总督发生冲突后，被押送到其父亲的领地米哈伊洛夫斯科耶村幽禁期间创作的一首诗歌。诗歌全文表述了一种积极乐观而坚强的人生态度，并且因它亲切和蔼的口气让许多人把它记于自己的笔记本上，成为了激励自己勇往直前，永不放弃的座右铭。 If by Life You Were Deceived If by life you were deceived, Don&#39;t be dismal,don&#39;t be wild! In the day of grief,be mild: Merry days will come,believe. Heart is living in tomorrow; Present is dejected here: In a moment,passes sorrow; That which passes will be dear. 假如生活欺骗了你 假如生活欺骗了你， 不要悲伤，不要心急！ 忧郁的日子里须要镇静： 相信吧，快乐的日子将会来临！ 心儿永远向往着未来； 现在却常是忧郁。 一切都是瞬息，一切都将会过去； 而那过去了的，就会成为亲切的怀恋。","categories":[{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"The Rose","slug":"2017-10-20-rose","date":"2017-10-19T16:00:00.000Z","updated":"2020-09-03T07:02:12.758Z","comments":true,"path":"2017/10/20/2017-10-20-rose/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-rose/","excerpt":"","text":"The Rose Some say love it is a river That drowns the tender reed Some say love it is a razor That leaves your soul to bleed Some say love it is a hunger An endless aching need I say love it is a flower And you , its only seed It&#39;s the heart afraid of breaking That never learns to dance It&#39;s the dream afraid of waking That never takes the chance It&#39;s the one who won&#39;t be taken Who cannot seem to give And the soul afraid of dying That never learns to live When the night has been too lonely And the road has been too long And you think that love is only For the lucky and the strong Just remember in the winter Far beneath the bitter snows Lies the seed that with the sun&#39;s love In the spring becomes the rose","categories":[{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Hello,world!","slug":"2017-10-19-你好世界","date":"2017-10-18T16:00:00.000Z","updated":"2020-09-03T07:02:05.051Z","comments":true,"path":"2017/10/19/2017-10-19-你好世界/","link":"","permalink":"http://jmiin.github.io/2017/10/19/2017-10-19-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","excerpt":"","text":"Hey Hello World 中文意思是『世界，你好』。因为《The C Programme Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。 Java12345678package text1;public class A &#123; public static void main(String[] args) &#123; System.out.printf(&quot;hello,world!&quot;); &#125;&#125; C123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125; VB12345Module MainFrm Sub Main() System.Console.WriteLine(&quot;Hello, World!&quot;) End SubEnd Module Python31print(&quot;Hello, World!&quot;) Ruby123def hello() return &quot;Hello , World&quot; end JavaScript1console.log(&quot;Hello, World!&quot;) C++1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;flush; return 0;&#125;","categories":[{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程实现及创建方式","slug":"Java基础/多线程/线程实现及创建方式","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"},{"name":"进程与线程","slug":"Java基础/多线程/进程与线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"},{"name":"Java集合","slug":"Java基础/Java集合","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"},{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"},{"name":"数据库","slug":"数据库","permalink":"http://jmiin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"大学时光","slug":"大学时光","permalink":"http://jmiin.github.io/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/"},{"name":"暂未分类","slug":"暂未分类","permalink":"http://jmiin.github.io/categories/%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Java常用关键字","slug":"Java常用关键字","permalink":"http://jmiin.github.io/tags/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"Java集合","slug":"Java集合","permalink":"http://jmiin.github.io/tags/Java%E9%9B%86%E5%90%88/"},{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"},{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}]}