{"meta":{"title":"JmiinBlog","subtitle":"","description":"靡不有初，鲜克有终。","author":"Jmiin","url":"http://jmiin.github.io","root":"/"},"pages":[],"posts":[{"title":"生活很苦，人生不苦!","slug":"2020-06-16-重新启程","date":"2020-06-15T16:00:00.000Z","updated":"2020-09-01T02:46:31.540Z","comments":true,"path":"2020/06/16/2020-06-16-重新启程/","link":"","permalink":"http://jmiin.github.io/2020/06/16/2020-06-16-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B/","excerpt":"","text":"生活就像一面镜子 你赠予它微笑，它回馈你美貌 你充斥着怒气，它回馈你丑陋 当生活像一首歌那样 轻快流畅时 笑颜常开乃易事 而在面对挫折时仍能乐观 希望就像灿烂的阳光 带着坚定的信念 突破重重云层","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"Jmiin"},{"title":"markdown详解","slug":"2017-10-25-makedown详解","date":"2017-10-24T16:00:00.000Z","updated":"2020-06-16T05:32:12.499Z","comments":true,"path":"2017/10/25/2017-10-25-makedown详解/","link":"","permalink":"http://jmiin.github.io/2017/10/25/2017-10-25-makedown%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://jmiin.github.io/tags/markdown/"}],"author":"Jmiin"},{"title":"Mysql简笔","slug":"2017-10-24-Mysql基本使用方法","date":"2017-10-23T16:00:00.000Z","updated":"2020-06-16T04:48:33.834Z","comments":true,"path":"2017/10/24/2017-10-24-Mysql基本使用方法/","link":"","permalink":"http://jmiin.github.io/2017/10/24/2017-10-24-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"启动服务 net start mysql net stop mysql 进入mysql 输入用户名密码。 mysql -u 用户名 -p 如：mysql -u root -p 效果如下： 查看基本命令 每条命令结束后一定要加分号 1.show databases; 查看数据库 2.use 数据库; 选择数据库并使用它 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。 如： 3.show tables; 查看use的数据库的tables（表）; 我这里有下面3个表： 4.select * from 表名; 查看某个表 5.show columns from 表名; 查看某个表中所有字段 以上几个命令是必须掌握的查看命令 SQL语句对MySQL的操作 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。库中有3个表各个表的数据如下： 基本表的定义、删除、与修（略） sql基本了解(注：sql语言不区分大小写） SQL语句之数据查询 基本结构如下：SELECT …FROM …WHERE … 一、 单表查询 1.查询全体学生的学号与姓名。 2.查询出生年月日。 3.消除取值重复的行 关键词distinct 4.聚集函数 where子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having子句。 SQL语句之数据更新一、插入数据 123INSERTINTO &lt;表名&gt; (&lt;属性列1&gt;,&lt;属性列2&gt;,...)VALUES (&#39;常量1&#39;,&#39;常量2&#39;,...) 推荐 如果想更好的了解推荐以下视频 与MySQL的零距离接触 SQL Server基础–T-SQL语句","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"}],"author":"Jmiin"},{"title":"递归的时间复杂度","slug":"2017-10-21-递归树","date":"2017-10-21T16:00:00.000Z","updated":"2020-06-16T04:48:33.834Z","comments":true,"path":"2017/10/22/2017-10-21-递归树/","link":"","permalink":"http://jmiin.github.io/2017/10/22/2017-10-21-%E9%80%92%E5%BD%92%E6%A0%91/","excerpt":"","text":"Master定理 有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的： 设常数a &gt;= 1，b &gt; 1，f(n)为函数，T(n)为非负整数，T(n) = a T(n / b) + f(n)，则有： 递归树没事间写QAQ………","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}],"author":"Jmiin"},{"title":"单片机","slug":"2017-10-21-T2定时器","date":"2017-10-20T16:00:00.000Z","updated":"2020-06-16T04:48:33.833Z","comments":true,"path":"2017/10/21/2017-10-21-T2定时器/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-T2%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"实验三思考题： 若系统时钟频率为12MHz，编写软件实现：按一下K键，产生一次外部中断1中断信号，启动T2定时，使P1.1输出周期为2秒的方波。 定时器T2,reg52.h没有T2MOD寄存器,regx55.h有T2MOD寄存器而且sbit已经定义。因此头文件用reg55.h。 参考代码:123456789101112131415161718192021222324252627#include &lt;regx55.h&gt;#define uint unsigned int#define uchar unsigned intsbit P11&#x3D;P1^1;uchar num&#x3D;0;void main()&#123; T2MOD&#x3D;0x00; TH2&#x3D;(65536-50000)&#x2F;256; TL2&#x3D;(65536-50000)%256; RCAP2H&#x3D;(65536-50000)&#x2F;256; RCAP2L&#x3D;(65536-50000)%256; IE&#x3D;0xa4; while(1)&#123; if(TF2)&#123; num++; TF2&#x3D;0; &#125; if(num&#x3D;&#x3D;20)&#123; P11&#x3D;~P11; num&#x3D;0; &#125; &#125;&#125;void INTer1() interrupt 2&#123; TR2&#x3D;1;&#125; 因为简单，所以没有注释。 运行结果： 代码工程及仿真","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"Jmiin"},{"title":"Jekyll","slug":"2017-10-21-jekyll","date":"2017-10-20T16:00:00.000Z","updated":"2020-06-16T04:48:33.834Z","comments":true,"path":"2017/10/21/2017-10-21-jekyll/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-jekyll/","excerpt":"","text":"Jekyll Jekyll网站的目录结构。 . ├── _config.yml ├── _data | └── members.yml ├── _drafts | ├── begin-with-the-crazy-ideas.md | └── on-simplicity-in-technology.md ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | └── post.html ├── _posts | ├── 2007-10-29-why-every-programmer-should-play-nethack.md | └── 2009-04-26-barcamp-boston-4-roundup.md ├── _sass | ├── _base.scss | └── _layout.scss ├── _site ├── .jekyll-metadata └── index.html # can also be an &#39;index.md&#39; with valid YAML Frontmatter test2 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 原文链接","categories":[],"tags":[{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}],"author":"Jmiin"},{"title":"假如生活欺骗了你","slug":"2017-10-20-假如生活欺骗了你","date":"2017-10-19T16:00:00.000Z","updated":"2020-06-16T04:48:33.832Z","comments":true,"path":"2017/10/20/2017-10-20-假如生活欺骗了你/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/","excerpt":"","text":"假如生活欺骗了你 《假如生活欺骗了你》是俄国诗人普希金于1825年流放南俄敖德萨同当地总督发生冲突后，被押送到其父亲的领地米哈伊洛夫斯科耶村幽禁期间创作的一首诗歌。诗歌全文表述了一种积极乐观而坚强的人生态度，并且因它亲切和蔼的口气让许多人把它记于自己的笔记本上，成为了激励自己勇往直前，永不放弃的座右铭。 If by Life You Were Deceived If by life you were deceived, Don&#39;t be dismal,don&#39;t be wild! In the day of grief,be mild: Merry days will come,believe. Heart is living in tomorrow; Present is dejected here: In a moment,passes sorrow; That which passes will be dear. 假如生活欺骗了你 假如生活欺骗了你， 不要悲伤，不要心急！ 忧郁的日子里须要镇静： 相信吧，快乐的日子将会来临！ 心儿永远向往着未来； 现在却常是忧郁。 一切都是瞬息，一切都将会过去； 而那过去了的，就会成为亲切的怀恋。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"Jmiin"},{"title":"The Rose","slug":"2017-10-20-rose","date":"2017-10-19T16:00:00.000Z","updated":"2020-06-16T04:48:33.832Z","comments":true,"path":"2017/10/20/2017-10-20-rose/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-rose/","excerpt":"","text":"The Rose Some say love it is a river That drowns the tender reed Some say love it is a razor That leaves your soul to bleed Some say love it is a hunger An endless aching need I say love it is a flower And you , its only seed It&#39;s the heart afraid of breaking That never learns to dance It&#39;s the dream afraid of waking That never takes the chance It&#39;s the one who won&#39;t be taken Who cannot seem to give And the soul afraid of dying That never learns to live When the night has been too lonely And the road has been too long And you think that love is only For the lucky and the strong Just remember in the winter Far beneath the bitter snows Lies the seed that with the sun&#39;s love In the spring becomes the rose","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"Jmiin"},{"title":"动态规划","slug":"2017-10-24-动态规划","date":"2017-10-19T16:00:00.000Z","updated":"2020-06-16T04:48:33.835Z","comments":true,"path":"2017/10/20/2017-10-24-动态规划/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-24-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"什么是动态规划（DP）？ DP起源于运筹学，是求解决策过程最优化的数学方法，它一种是将多阶段过程转化为一系列单阶段问题，再利用各阶段之间的关系，逐个求解的方法。即动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。 动态规划干什么用？ 求解决策过程最优化。因此动态规划算法通常用于求解具有某种最优性质的问题。 通常可按以下4个步骤设计： 找出最优解的性质，并刻画其结构特征。 递归地定义最优值。 以自底向上的方式计算出最优解。 根据计算最优值时得到的信息，构造最优解。 动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。 如： 线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等； 区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等； 树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等； 背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶 等； 经典例题01背包问题 问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 如：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 本题特点是：每种物品仅有一件，可以选择放或不放。 F[i，j]表示在前i个物品中能够装入容量为j的背包中的最大价值。同时设v[i]、w[i]分别为第i个物品的价值和重量，v为背包的容量。 其状态转移方程便是： F[i, v] = maxf&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125; 二维0-1背包问题 给定n种物品和一个背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为c，容积为d。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品只有两个选择：装入或不装入，且不能重复装入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class twobage &#123; public static int maxx(int a, int b) &#123; if (a &gt;= b) return a; else return b; &#125; public static void main(String[] args) &#123; int[] weight = &#123;5,3,8 &#125;; // 物品重量 int[] val = &#123; 7,8,9 &#125;; // 物品价值 int[] b = &#123; 4,6,2 &#125;; int z = 30; // 背包容积 int p, q, i, m = 10; // 背包容量 int n = val.length; // 物品个数 int[][][] f = new int[n + 1][m + 1][z + 1]; // f[i][x][y]表示只允许装前i种物品，背包总重不超过x,物品总体积不超过y时，背包最大价值 int[] path = new int[n + 1]; //下标加1对应物品下标，其值为0代表不放，为1代表放 for (i = 0; i &lt;= n; i++) f[i][0][0] = 0; for (p = 0; p &lt;= m; p++) for (q = 0; q &lt;= z; q++) f[0][p][q] = 0; for (i = 1; i &lt;= n; i++) for (p = 1; p &lt;= m; p++) for (q = 1; q &lt;= z; q++) &#123; if (p &lt; weight[i - 1] || q &lt; b[i - 1]) &#123; f[i][p][q] = f[i - 1][p][q]; &#125;else &#123; f[i][p][q] = maxx(f[i - 1][p][q], f[i - 1][p - weight[i - 1]][q - b[i - 1]] + val[i - 1]); &#125; &#125; p = m; q = z; for (i = n; i &gt;= 1; i--) &#123; if (f[i][p][q] &gt; f[i - 1][p][q]) &#123; path[i] = 1; p = p - weight[i-1]; q = q - b[i-1]; &#125; else path[i] = 0; &#125; System.out.print(&quot;path值：&quot;); for (i = 1; i &lt;= n; i++) System.out.print(path[i] + &quot; &quot;); System.out.println(); System.out.print(&quot;放入的物品为：&quot;); for (i = 1; i &lt;= n; i++) if(path[i]==1) System.out.print(i-1+&quot;号 &quot;); System.out.println(); int r = 0; for (i = 1; i &lt;= n; i++) &#123; if (path[i] == 1) r += val[i - 1]; else r += 0; &#125; System.out.print(&quot;最大价值为：&quot;+r); &#125;&#125; 更多背包问题可以参考背包九讲 动态规划算法的基本要素1. 最优子结构2. 重叠子问题3. 边界4. 子问题独立5. 备忘录方法这里举个简单的例题：动态规划入门-数字三角形 Description 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得 路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //三角形行数。下面是三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 Sample Output 30 代码： import java.util.Scanner; public class triangle &#123; /* 测试数据： 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 */ private static int max(int a, int b) &#123; if(a&gt;b) return a; else return b; &#125; public static void main(String[] args) &#123; System.out.print(&quot;请输入行数：&quot;); Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[][] a=new int[n+2][n+2]; int[][] path=new int[n+2][n+2]; int pmax=0; for(int i=0;i&lt;n+2;i++) &#123; a[i][i]=0; &#125; for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt;i;j++) &#123; a[i][j]=(int)sc.nextInt(); &#125; &#125; //输出测试数组 /*for(int i=0;i&lt;=n+1;i++) &#123; for(int j=0;j&lt;i+1;j++) &#123; System.out.print(a[i][j]+&quot; &quot;); &#125;System.out.println(); &#125;*/ for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; path[i][j]=max(path[i-1][j],path[i-1][j-1])+a[i][j]; &#125; &#125; //输出子问题值 for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; System.out.print(path[i][j]+&quot; &quot;); if (pmax &lt; path[i][j]) &#123; pmax = path[i][j];//算出最大值 &#125; &#125; System.out.println(); &#125; System.out.println(&quot;最大值为：&quot;+pmax); &#125; &#125; 更多感悟，如果还有下次，再见~","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}],"author":"Jmiin"},{"title":"Hello,world!","slug":"2017-10-19-你好世界","date":"2017-10-18T16:00:00.000Z","updated":"2020-09-01T02:43:51.402Z","comments":true,"path":"2017/10/19/2017-10-19-你好世界/","link":"","permalink":"http://jmiin.github.io/2017/10/19/2017-10-19-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","excerpt":"","text":"Hey Hello World 中文意思是『世界，你好』。因为《The C Programme Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。 Java12345678package text1;public class A &#123; public static void main(String[] args) &#123; System.out.printf(&quot;hello,world!&quot;); &#125;&#125; C123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125; VB12345Module MainFrm Sub Main() System.Console.WriteLine(&quot;Hello, World!&quot;) End SubEnd Module Python31print(&quot;Hello, World!&quot;) Ruby123def hello() return &quot;Hello , World&quot; end JavaScript1console.log(&quot;Hello, World!&quot;) C++1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;flush; return 0;&#125;","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"Jmiin"}],"categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"markdown","slug":"markdown","permalink":"http://jmiin.github.io/tags/markdown/"},{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"},{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}]}