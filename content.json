{"meta":{"title":"JmiinBlog","subtitle":"","description":"靡不有初，鲜克有终。","author":"Jmiin","url":"http://jmiin.github.io","root":"/"},"pages":[{"title":"","date":"2020-09-03T09:02:24.631Z","updated":"2020-09-03T09:02:24.631Z","comments":true,"path":"about/index.html","permalink":"http://jmiin.github.io/about/index.html","excerpt":"","text":"年少轻狂的好日子，一懂事就结束。"},{"title":"所有标签","date":"2020-09-03T09:42:57.516Z","updated":"2020-09-03T09:42:57.516Z","comments":true,"path":"tags/index.html","permalink":"http://jmiin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-03T08:54:43.931Z","updated":"2020-09-03T08:54:43.931Z","comments":true,"path":"404.html","permalink":"http://jmiin.github.io/404.html","excerpt":"","text":"12345678910cover: truerobots: noindex,nofollowsitemap: falselayout: docsseo_title: 404 Not Foundbottom_meta: falsesidebar: []valine: path: &#x2F;404.html placeholder: 请留言告诉我您要访问哪个页面找不到了 404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-09-03T09:42:48.290Z","updated":"2020-09-03T09:42:48.290Z","comments":true,"path":"categories/index.html","permalink":"http://jmiin.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-03T09:42:15.283Z","updated":"2020-09-03T09:42:15.283Z","comments":true,"path":"friends/index.html","permalink":"http://jmiin.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"并发底层实现原理","slug":"2020-09-12-并发底层实现原理","date":"2020-09-11T16:00:00.000Z","updated":"2020-09-15T03:09:35.249Z","comments":true,"path":"2020/09/12/2020-09-12-并发底层实现原理/","link":"","permalink":"http://jmiin.github.io/2020/09/12/2020-09-12-%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"Java代码编译后形成字节码文件，字节码被类加载器加载到JVM中，JVM将字节码转换为汇编指令在CPU上执行，整个过程并发机制的实现全部依赖于JVM和CPU的指令。 volatilesynchronizedCAS与原子操纵","categories":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发原理","slug":"多线程/并发原理","permalink":"http://jmiin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"单例模式","slug":"2020-09-11-单例模式","date":"2020-09-10T16:00:00.000Z","updated":"2020-09-14T09:47:44.988Z","comments":true,"path":"2020/09/11/2020-09-11-单例模式/","link":"","permalink":"http://jmiin.github.io/2020/09/11/2020-09-11-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://jmiin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"设计模式/单例模式","permalink":"http://jmiin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"单例模式","slug":"单例模式","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"AOP就是个P","slug":"2020-09-10-AOP就是个P","date":"2020-09-09T16:00:00.000Z","updated":"2020-09-13T06:14:51.249Z","comments":true,"path":"2020/09/10/2020-09-10-AOP就是个P/","link":"","permalink":"http://jmiin.github.io/2020/09/10/2020-09-10-AOP%E5%B0%B1%E6%98%AF%E4%B8%AAP/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"http://jmiin.github.io/categories/Spring/"},{"name":"AOP","slug":"Spring/AOP","permalink":"http://jmiin.github.io/categories/Spring/AOP/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://jmiin.github.io/tags/Spring/"}]},{"title":"Java内存模型","slug":"2020-09-09-Java内存模型","date":"2020-09-08T16:00:00.000Z","updated":"2020-09-15T03:09:29.201Z","comments":true,"path":"2020/09/09/2020-09-09-Java内存模型/","link":"","permalink":"http://jmiin.github.io/2020/09/09/2020-09-09-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"在并发编程中，需要注意两个关键问题： 线程间如何通信? 即: 线程间以何种机制来交换信息. 线程间如何同步? 即: 线程间以何种机制来控制不同线程间操作发生的相对顺序. 在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 两种内存模型比较 模型 如何通信 如何同步 共享内存 线程之间共享内存的公共状态，通过写-读内存中的公共状态进行隐式的通信。 同步是显式进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。 消息传递 线程之间没有公共状态，线程之间必须通过发送消息来显式的通信。 由于消息的发送必须在消息接收之前，因此同步是隐式执行的。 Java的并发采用的是共享内存模型，它的线程之间的通信总是隐式执行的。 Java内存模型的抽象结构运行时内存的划分先看下运行时数据区： 堆在线程间是共享的，而所有的实例域、静态域和数组元素等变量都存储在堆内存（这些元素统一被称为共享变量）。而栈中的变量（局部变量、方法定义的参数、异常处理器的参数等）不会在线程之间共享，也就不会存在 内存可见性 。内存可见性针对的是共享变量。 堆的内存不可见问题现代计算机为了高效，会在高速缓存区中缓存共享变量，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，它存储了该线程以读、写共享变量的拷贝（副本）。本地内存是JMM的一个抽象的概念，并不真实存在。 从图中可以看出： 所有的共享变量都存储在主内存中。 每个线程都保留了一份该线程使用到了的共享变量的拷贝。 如果A与B两个线程进行通信的话，需要经过以下两个步骤: A将本地内存中被更新过的共享变量副本刷新到主内存中。 B需要到主内存中去读取A之前已经更新过的共享变量。 整个过程中A、B是无法之间访问对方的工作内存的，线程之间的通信必须经过主内存。 注意：根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。 因此B并不是直接到主内存读取共享变量的值，而是先在本地内存中找到这个共享变量，发现这个共享变量已经被更新了，然后B去主内存中读取这个共享变量的新值，并拷贝到B的本地内存中，最后B在从本地内存读取新值。 JMM正是通过控制主内存与每个线程的本地内存之间的交互来为Java程序员提供内存可见性的保证。 Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅可以保证可见性，同时也可以保证原子性。 指令的重排序 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。 1、编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 2、指令级并行的重排序：多条指令不存在数据依赖时，处理器可以改变语句对应机器指令的执行顺序。 3、内存系统的重排序。 从源码到最终的执行序列会按上述顺序进行重排序。 这些重排序很可能导致多线程程序出现内存可见性的问题。 对于编译器，JMM规定会禁止特定类型的编译器重排序。 对于处理器，JMM规定**在生成指令序列时，插入特定类型的内存屏障（Memory Barriers）指令，通过它来禁止。 happens-before Java内存模型使用happens-before的概念来描述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B且B happens-before C，那么A happens-before C。 两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。 通俗的讲，happens-before可以理解为发生在某某之前，其主要是为了体现程序执行的顺序性，而这种顺序性保证了JMM的内存可见性。 JMM与Java内存区域区别两者是不同的概念层次，JMM是抽象的，是用来描述一组规则，通过这个规则实现了线程的通信和同步。 而Java运行时的内存的划分是具象的，是JVM运行Java程序时，必要的内存划分。 联系都存在私有的数据区域和共享数据区域。 JMM中主内存属于共享数据区域，包含堆和方法区。 JMM中本地内存属于私有数据区域，包含了程序计数器、本地方法区、虚拟机栈。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程同步","slug":"2020-09-08-线程同步","date":"2020-09-07T16:00:00.000Z","updated":"2020-09-15T03:09:23.144Z","comments":true,"path":"2020/09/08/2020-09-08-线程同步/","link":"","permalink":"http://jmiin.github.io/2020/09/08/2020-09-08-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"每一个线程都有其自己的私有上下文，当多个线程需要共同合作完成某项任务时，两者必定是会产生通信，而线程间的通信完全围绕它们共同持有的资源进行的。 锁与同步","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程组及线程优先级","slug":"2020-09-07-线程组及线程优先级","date":"2020-09-06T16:00:00.000Z","updated":"2020-09-15T03:09:19.537Z","comments":true,"path":"2020/09/07/2020-09-07-线程组及线程优先级/","link":"","permalink":"http://jmiin.github.io/2020/09/07/2020-09-07-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"线程组数据结构 线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统⼀控制线程的优先级和检查线程的权限的作用。 1234567891011121314public class ThreadGroup implements Thread.UncaughtExceptionHandler &#123; private final ThreadGroup parent; // ⽗亲ThreadGroup String name; // ThreadGroupr 的名称 int maxPriority; // 线程最大优先级 boolean destroyed; // 是否被销毁 boolean daemon; // 是否守护线程 boolean vmAllowSuspension; // 是否可以中断 int nUnstartedThreads = 0; // 还未启动的线程 int nthreads; // ThreadGroup中线程数目 Thread threads[]; // ThreadGroup中的线程 int ngroups; // 线程组数目 ThreadGroup groups[]; // 线程组数组 ......&#125; 线程组可以包含线程也可以包含其它线程组 如果在new Thread()时没有显示的指定线程的线程组，那么默认将它的父线程的线程组设置为自己的线程组。 123456789101112131415161718public class ThreadDemo &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println(&quot;当前线程&quot; + Thread.currentThread().getName() + &quot;的线程组的名字为：&quot; + Thread.currentThread().getThreadGroup().getName()); &#125;).start(); System.out.println(&quot;main线程的线程组的名字为：&quot; + Thread.currentThread().getThreadGroup().getName()); &#125;&#125;运行结果： main线程的线程组的名字为：main当前线程Thread-0的线程组的名字为：mainProcess finished with exit code 0 常用方法 线程组基本的常用方法如下 返回值 方法名 int activeCount() 返回此线程组中活动线程的估计数。 int activeGroupCount() 返回此线程组中活动线程组的估计数。 void checkAccess() 确定当前运行的线程是否有权修改此线程组。 void destroy() 销毁此线程组及其所有子组。 int enumerate(Thread[] list) 把此线程组及其子组中的所有活动线程复制到指定数组中。 int enumerate(Thread[] list, boolean recurse) 把此线程组中的所有活动线程复制到指定数组中。 int enumerate(ThreadGroup[] list) 把对此线程组中的所有活动子组的引用复制到指定数组中。 int enumerate(ThreadGroup[] list, boolean recurse) 把对此线程组中的所有活动子组的引用复制到指定数组中。 int getMaxPriority() 返回此线程组的最高优先级。 String getName() 返回此线程组的名称。 ThreadGroup getParent() 返回此线程组的父线程组。 void interrupt() 中断此线程组中的所有线程。 boolean isDaemon() 测试此线程组是否为一个守护线程。 boolean isDestroyed() 测试此线程组是否已经被销毁。 void list() 将有关此线程组的信息打印到标准输出。 boolean parentOf(ThreadGroup g) 测试此线程组是否为线程组参数或其祖先线程组之一。 void setDaemon(boolean daemon) 更改此线程组的后台程序状态。 void setMaxPriority(int pri) 设置线程组的最高优先级。 void uncaughtException(Thread t, Throwable e) 当此线程组中的线程因为一个未捕获的异常而停止，并且线程没有设置特定 Thread.uncaughtExceptionHandler时，由 Java Virtual Machine 调用此方法。 1234567891011121314151617181920212223其中uncaughtExceptionHandler为线程池捕获线程成员的异常接口 public static void testUncatchException() &#123; ThreadGroup threadGroup1 = new ThreadGroup(&quot;group1&quot;) &#123; // 继承ThreadGroup并重新定义以下方法 // 在线程成员抛出unchecked exception // 会执行此方法 @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(t.getName() + &quot;: &quot; + e.getMessage()); &#125; &#125;; // 这个线程是threadGroup1的⼀员 Thread thread1 = new Thread(threadGroup1, ()-&gt; &#123; // 抛出unchecked异常 throw new RuntimeException(&quot;测试异常&quot;); &#125;); thread1.start(); &#125;运行结果：Thread-0: 测试异常 Process finished with exit code 0 线程优先级 线程中的优先级由低到高指定范围为1~10，默认为5，但是线程执行的本质还有由CPU的调度来决定的，只是通常情况下高优先级的线程更有可能被分配到资源优先执行。 Java提供一个线程调度器来监视和控制处于Runnable状态的线程。其调度方式是抢占式的，在相同优先级的情况下按照”先到先得”的原则进行。 守护线程（Deamon)： 守护线程的优先级比较低，某线程是守护线程，如果其它所有的非守护线程结束，这个守护线程也会自动结束。这样的操作可以免去关闭子线程的麻烦。 线程默认是非守护线程，可以通过Thread类中的setDeamon(boolean on)来设置。 线程和线程组都存在优先级，如果属于该线程组的线程的优先级和它的线程组的优先级不一样会发生什么？ 123456789101112public static void diffPriority() &#123; ThreadGroup threadGroup = new ThreadGroup(&quot;t1&quot;); threadGroup.setMaxPriority(6); Thread thread = new Thread(threadGroup, &quot;thread&quot;); thread.setPriority(9); System.out.println(&quot;我是线程组的优先级&quot; + threadGroup.getMaxPriority()); System.out.println(&quot;我是线程的优先级&quot; + thread.getPriority());&#125;运行结果：我是线程组的优先级6我是线程的优先级6 所以，如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程实现及创建方式","slug":"2020-09-06-线程实现及创建方式","date":"2020-09-05T16:00:00.000Z","updated":"2020-09-15T03:09:15.826Z","comments":true,"path":"2020/09/06/2020-09-06-线程实现及创建方式/","link":"","permalink":"http://jmiin.github.io/2020/09/06/2020-09-06-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/","excerpt":"","text":"线程的基本状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public enum State &#123; /** * Thread state for a thread which has not yet started. * 初始状态，线程被构建，但是还没有调用start()方法 */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. * 运行状态，Java线程将操作系统中的就绪和运行状态笼统的称作：运行中 * */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. * 阻塞状态，表示线程阻塞于锁 */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. * 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定的动作 *(通知或中断) */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; * 超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的 * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. * 终止状态，表示当前线程已经执行完毕 */ TERMINATED;&#125; 线程并不是始终固定于某一个状态而是随着代码的执行在不同状态之间进行切换的。 线程的创建方式继承Thread类 继承 Thread 类，并重写 run ⽅法； 123456789101112131415public class TestThread &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new ThreadDemo()); thread.start(); &#125; static class ThreadDemo extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;MyThread&quot;); &#125; &#125;&#125; 我们在程序里面调用了start()方法后，虚拟机会先为我们创建⼀个线程，然后等到这个线程第⼀次得到时间片时再调⽤run()方法。 注意不可多次调用start()方法。在第⼀次调start()方法后，再次调用start() 方法会抛出异常 实现Runnable接口 接着我们来看⼀下 Runnable 接⼝(JDK 1.8 +)： 12345678910111213141516@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#x27;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 一个经典的函数式接口，这意味着我们可以使用Java 8 的函数式编程来简化代码。 12345678public class ImplRunnable &#123; public static void main(String[] args) &#123; //静态代理的方式实现线程 new Thread(()-&gt; System.out.println(&quot;Impl Runnable Thread&quot;)).start(); &#125;&#125; new Thread(Runnable target)本质上是使用静态代理的方式实现的。 Thread类构造方法123456789101112131415161718192021222324 public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);&#125;public Thread(Runnable target, String name) &#123; init(null, target, name, 0);&#125;// ⽚段1 - init⽅法private void init(ThreadGroup g, Runnable target, String name,long stackSize,AccessControlContext acc,boolean inheritThreadLocals) // ⽚段2 - 构造函数调⽤init⽅法public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);&#125;// ⽚段3 - 使⽤在init⽅法⾥初始化AccessControlContext类型的私有属性this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext();// ⽚段4 - 两个对⽤于⽀持ThreadLocal的私有属性ThreadLocal.ThreadLocalMap threadLocals = null;ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; Thread类的几个常用的方法 currentThread()：静态方法，返回对当前正在执行的线程对象的引用； start()：开始执行线程的方法，java虚拟机会调⽤线程内的run()方法； yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调⽤了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的； sleep()：静态方法，使当前线程睡眠⼀段时间； join()：使当前线程等待另⼀个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的； Thread类与Runnable接口的比较实现⼀个自定义的线程类，可以有继承 Thread 类或者实现 Runnable 接⼝这两种方式，它们之间有什么优劣呢？ 由于Java“单继承，多实现”的特性，Runnable接口使⽤起来比Thread更灵活。 Runnable接口出现更符合面向对象，将线程单独进行对象的封装。 Runnable接口出现，降低了线程对象和线程任务的耦合性。 如果使用线程时不需要使⽤Thread类的诸多⽅法，显然使用Runnable接口更为轻量。 所以，我们通常优先使用“实现 Runnable 接口”这种方式来自定义线程类 Callable接口、Future接口 使用以上两种方式创建的线程是无返回值的。而有时候我们希望开启线程去执行某项任务时能动态的返回执行完毕后的结果。 JDK提供了 Callable 接口与 Future 类为我们解决这个问题，这也是所谓的“异步”模型。 Callable接口12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callable接口一般是配合线程池工具ExecutorService来使用的。通过submit()方法让一个Callable接口执行。它会返回一个Future。通过Future的get方法可以得到执行结果。 1234567891011121314151617181920212223242526public class ImplCallable implements Callable&lt;String&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ @Override public String call() throws Exception &#123; return &quot;Impl Callable&quot;; &#125; public static void main(String[] args) &#123; //这里是演示使用该方法，正常情况下是不允许的 ExecutorService executorService = Executors.newCachedThreadPool(); ImplCallable implCallable = new ImplCallable(); Future&lt;String&gt; submit = executorService.submit(implCallable); System.out.println(submit.get()); executorService.shutdown(); &#125;&#125;/*** 运行结果：* Impl Callable*/ 注意：阿里巴巴开发手册：线程池不允许使用 Executors 去创建后文会提到。 Future接口12345678910111213public interface Future&lt;V&gt; &#123; //试图取消一个线程的执行，返回是否取消成功 boolean cancel(boolean mayInterruptIfRunning); //判断当前方法是否取消 boolean isCancelled(); //判断当前方法是否完成 boolean isDone(); //当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕 V get() throws InterruptedException, ExecutionException; //多等待timeout的时间就会返回结果 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 一般Future是和线程池搭配使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Future和ExecutorService搭配使用 * 运行程序的主机是12线程的，因此启动了12个线程，每次会同时执行12个task。 * */public class TestFuture &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //匿名内部类声明 Callable&lt;Long&gt; callable = new Callable&lt;Long&gt;() &#123; @Override public Long call() throws Exception &#123; long start = System.currentTimeMillis(); Thread.sleep(100); long end = System.currentTimeMillis(); long seed = end - start; System.out.println(Thread.currentThread().getName()+&quot; seed=&quot; + seed); return seed; &#125; &#125;; List&lt;Callable&lt;Long&gt;&gt; tasks = new ArrayList&lt;&gt;(); //循环添加24次 for(int i = 0; i &lt; 24; i++) &#123; tasks.add(callable); &#125; //判断计算机的线程 int poolSize = Runtime.getRuntime().availableProcessors(); System.out.println(&quot;poolSize=&quot; + poolSize); ExecutorService executorService = Executors.newFixedThreadPool(poolSize); List&lt;Future&lt;Long&gt;&gt; futures = executorService.invokeAll(tasks); long result = 0; for (Future&lt;Long&gt; future : futures) &#123; result += future.get(); &#125; System.out.println(&quot;result=&quot; + result); executorService.shutdown(); &#125;&#125; 运行结果： poolSize=12 pool-1-thread-8 seed=100 pool-1-thread-4 seed=100 pool-1-thread-2 seed=100 pool-1-thread-3 seed=100 pool-1-thread-7 seed=100 pool-1-thread-5 seed=100 pool-1-thread-1 seed=100 pool-1-thread-6 seed=100 pool-1-thread-9 seed=100 pool-1-thread-10 seed=100 pool-1-thread-11 seed=100 pool-1-thread-12 seed=100 pool-1-thread-9 seed=101 pool-1-thread-1 seed=101 pool-1-thread-3 seed=101 pool-1-thread-10 seed=101 pool-1-thread-12 seed=101 pool-1-thread-11 seed=101 pool-1-thread-8 seed=101 pool-1-thread-4 seed=101 pool-1-thread-2 seed=101 pool-1-thread-7 seed=101 pool-1-thread-5 seed=101 pool-1-thread-6 seed=101 result=2412 基于线程池的方式1池化技术相信大家已经屡见不鲜了，线程池、数据库连接池、 Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 如何创建线程池《阿里巴巴Java开发手册》中强制线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 。 ThreadPoolExecutor 类提供了4个构造方法： 12345678910111213141516171819202122232425262728public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue);public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory);public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler);//⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。以上3个构造方法都是建立在这个基础上public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); ThreadPoolExecutor构造函数重要参数分析 ThreadPoolExecutor 3个最重要的参数： corePoolSize: 核心线程数线程数定义了最小可以同时运行的线程数量。 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会⼀直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 该值等于核心线程数量 + 非核心线程数量。 workQueue :阻塞队列， 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他参数： keepAliveTime: 非核心线程闲置超时时长。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁； unit: 上面参数的时间单位。 unit是⼀个枚举类型 ，包括以下属性： NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天 threadFactory: 创建线程的⼯⼚ ，⽤于批量创建线程，统⼀在创建线程时设置⼀些参数，如是否守护线程、线程的优先级等。如果不指定，会新建⼀个默认的线程工厂 handler：饱和策略。 饱和策略： 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor定义一些策略： RejectedExecutionHandler具体的实现类有4种: 可以参考这4个实体类的源码，饱和后的操作都是实现rejectedExecution(Runnable r,ThreadPoolExecutor executor)方法 ，它们都是ThreadPoolExecutor 的静态内部类： ThreadPoolExecutor.AbortPolicy ：抛出 RejectedExecutionException 来拒绝新任务的处理 。 ThreadPoolExecutor.CallerRunsPolicy ：简单点说就是后面排队的线程就在那儿等着。调用执行当前传入的线程进行运行。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果应用程序可以承受此延迟并且不能丢弃任何⼀个任务请求的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy ： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy ： 此策略将丢弃最早的未处理的任务请求。 线程池主要的任务处理流程 (重要) 当线程池接收到一个任务时，主要是通过源码中的execute()方法去执行的； 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&#x27;t, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ // 1.当前线程数⼩于corePoolSize,则调⽤addWorker创建核⼼线程执行任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 2.如果不⼩于corePoolSize，则将任务添加到workQueue队列。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行饱和策略。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 2.2 线程池处于running状态，但是没有线程，则创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 3.如果放⼊workQueue失败，则创建非核⼼线程执⾏任务， // 如果这时创建非核⼼线程失败(当前线程总数不⼩于maximumPoolSize时)，就会执行饱和策略。 else if (!addWorker(command, false)) reject(command); &#125; 主要分为3步： 1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3、线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 实例演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ThreadPoolExecutorDemo &#123; // 最大核心线程数 public static final int CORE_POOL_SIZE = 5; // 最大线程数 public static final int MAXINUM_POOL_SIZE = 10; // 最大队列长度 public static final int QUEUE_CAPACITY = 100; // 非核心线程闲置超时时间 public static final Long KEEP_ALIVE_TIME = 1L; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXINUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); //1. 线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行 //任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt;corePoolSize时）。 // 注意，这一步需要获得全局锁。 //2. 线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然 //后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。 //3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行 //这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得 //全局锁。 //4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的 //饱和策略进行处理。 //最大任务数 int maxTask = 1000; for (int i = 0; i &lt; maxTask; i++) &#123; Runnable task = ()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot; Start.Time = &quot; +new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date())); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; End.Time = &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date())); &#125;; // 执行Runnable executor.execute(task); &#125; executor.shutdown(); &#125;&#125; 1. 当maxTask小于缓存队列的长度时(如：maxTask = 10)，线程池不需要创建非核心线程来处理任务 运行结果： pool-1-thread-2 Start.Time = 09:25:19 pool-1-thread-3 Start.Time = 09:25:19 pool-1-thread-5 Start.Time = 09:25:19 pool-1-thread-4 Start.Time = 09:25:19 pool-1-thread-1 Start.Time = 09:25:19 pool-1-thread-1 End.Time = 09:25:21 pool-1-thread-2 End.Time = 09:25:21 pool-1-thread-4 End.Time = 09:25:21 pool-1-thread-3 End.Time = 09:25:21 pool-1-thread-5 End.Time = 09:25:21 pool-1-thread-4 Start.Time = 09:25:21 pool-1-thread-3 Start.Time = 09:25:21 pool-1-thread-2 Start.Time = 09:25:21 pool-1-thread-1 Start.Time = 09:25:21 pool-1-thread-5 Start.Time = 09:25:21 pool-1-thread-3 End.Time = 09:25:23 pool-1-thread-5 End.Time = 09:25:23 pool-1-thread-1 End.Time = 09:25:23 pool-1-thread-2 End.Time = 09:25:23 pool-1-thread-4 End.Time = 09:25:23 Process finished with exit code 0 2. 当maxTask大于缓存队列的长度时(如：maxTask = 210)，线程池不需要创建非核心线程来处理任务 运行结果为： pool-1-thread-10 Start.Time = 09:26:56 pool-1-thread-7 Start.Time = 09:26:56 pool-1-thread-1 Start.Time = 09:26:56 pool-1-thread-9 Start.Time = 09:26:56 pool-1-thread-8 Start.Time = 09:26:56 pool-1-thread-2 Start.Time = 09:26:56 pool-1-thread-4 Start.Time = 09:26:56 pool-1-thread-6 Start.Time = 09:26:56 main Start.Time = 09:26:56 pool-1-thread-3 Start.Time = 09:26:56 pool-1-thread-5 Start.Time = 09:26:56 pool-1-thread-5 End.Time = 09:26:58 pool-1-thread-3 End.Time = 09:26:58 pool-1-thread-1 End.Time = 09:26:58 pool-1-thread-6 End.Time = 09:26:58 pool-1-thread-9 End.Time = 09:26:58 ......","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"进程与线程","slug":"2020-09-05-进程与线程","date":"2020-09-04T16:00:00.000Z","updated":"2020-09-15T03:09:11.777Z","comments":true,"path":"2020/09/05/2020-09-05-进程与线程/","link":"","permalink":"http://jmiin.github.io/2020/09/05/2020-09-05-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程与线程基本概念 一切都是为了提高系统资源利用率，提高系统吞吐量而生。 背景最初的时候的计算机完全由用户输入的指令控制执行，当用户停止时，计算机也会停止。这样效率及其低下。尽管后面出来的批处理系统可以将指令形成一套连续的流程对计算机进行控制，但是运行方式 仍然是串行的，内存中永远都是只有一个程序在运行，所以批处理效率也并不高。 内存完全是可以存在多个程序同时进行的。于是，进程由此诞生，进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的，各个进程之间互相不干扰。同时进程保存着程序每一个时刻运行的状态。 此时，CPU采用时间片轮询的方式运行进程：如果时间片结束进程还没有执行完毕，则暂停这个进程的运行，并且把CPU分配给其他的进程，这个过程就叫做上下文切换。 它的出现让操作系统的并发成为了可能，虽然并发从宏观上看有多个任务在执⾏，但在事实上，对于单核CPU来说，任意具体时刻都只有⼀个任务在占⽤CPU资源。 线程的提出进程的出现并不能让人们满足，如果⼀个进程有多个⼦任务时，只能逐个得执行这些子任务，很影响效率。为了同时让这些子任务同时执行，于是线程的提出变成了理所当然，每个线程负责一个单独的子任务。 线程与进程相似，但线程是⼀个⽐进程更小的执⾏单位。⼀个进程在其执⾏的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同⼀块内存空间和⼀组系统资源，所以系统在产生⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程小得多，也正因为如此，线程也被称为轻量级进程。 多线程实现并发的好处1.进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。2.进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。 两者之间的区别进程是一个独立的运行环境，而线程是在进程中执行的一个任务。它们本质的区别是是否单独占有内存地址空间及其它系统资源： 1.进程单独占由一定的内存地址空间，它们之间是存在内存隔离，数据是分开的，数据共享复杂但是同步简单各个进程之间互不干扰；而线程共享所属进程占用的内存地址空间和资源，数据共享简单，但是同步复杂。 2.进程单独占有一定的内存地址空间，一个进程出现问题不会影响其它进程，不影响主程序的稳定性，可靠性高；一个线程奔溃可能影响整个程序的稳定性，可靠性低。 3.进程单独占有一定的内存地址空间，进程的创建和销毁不仅仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销大；线程只需要保存寄存器和栈信息，开销小。 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。 并发与并行并发： 同⼀时间段，多个任务都在执行 (单位时间内不⼀定同时执行 )。并行： 单位时间内，多个任务同时执行 。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java常用关键字","slug":"2020-09-03-java常用关键字","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-03T07:04:33.921Z","comments":true,"path":"2020/09/03/2020-09-03-java常用关键字/","link":"","permalink":"http://jmiin.github.io/2020/09/03/2020-09-03-java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"​ final 关键字final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； final修饰的方法不能被重写； final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static 关键字static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this 关键字this关键字用于引用类的当前实例。 例如： 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println(&quot;Total employees: &quot; + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在上面的示例中，this关键字用于两个地方： this.employees.length：访问类Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。 此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。 super 关键字super关键字用于从子类访问父类的变量和方法。 例如： 1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 使用 this 和 super 要注意的问题： 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 static 关键字详解static 关键字主要有以下四种使用场景 修饰成员变量和成员方法 静态代码块 修饰类(只能修饰内部类) 静态导包(用来导入类中的静态资源，1.5之后的新特性) 修饰成员变量和成员方法(常用)被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。 调用格式： 类名.静态变量名 类名.静态方法名() 如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。 测试方法： 1234567891011121314151617181920public class StaticBean &#123; String name; //静态变量 static int age; public StaticBean(String name) &#123; this.name = name; &#125; //静态方法 static void SayHello() &#123; System.out.println(&quot;Hello i am java&quot;); &#125; @Override public String toString() &#123; return &quot;StaticBean&#123;&quot;+ &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;&#125;&quot;; &#125;&#125; 1234567891011121314public class StaticDemo &#123; public static void main(String[] args) &#123; StaticBean staticBean = new StaticBean(&quot;1&quot;); StaticBean staticBean2 = new StaticBean(&quot;2&quot;); StaticBean staticBean3 = new StaticBean(&quot;3&quot;); StaticBean staticBean4 = new StaticBean(&quot;4&quot;); StaticBean.age = 33; System.out.println(staticBean + &quot; &quot; + staticBean2 + &quot; &quot; + staticBean3 + &quot; &quot; + staticBean4); //StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125; StaticBean.SayHello();//Hello i am java &#125;&#125; 静态代码块静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 123static &#123; 语句体; &#125; 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问. 静态内部类静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非static成员变量和方法。 Example（静态内部类实现单例模式） 123456789101112131415public class Singleton &#123; //声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 静态导包格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 123456789101112131415 //将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用 //如果只想导入单一某个静态方法，只需要将换成对应的方法名即可 import static java.lang.Math.*;//换成import static java.lang.Math.max;具有一样的效果 public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; 补充内容静态方法与非静态方法静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 Example 12345678910111213141516class Foo &#123; int i; public Foo(int i) &#123; this.i = i; &#125; public static String method1() &#123; return &quot;An example string that doesn&#x27;t depend on i (an instance variable)&quot;; &#125; public int method2() &#123; return this.i + 1; //Depends on i &#125;&#125; 你可以像这样调用静态方法：Foo.method1()。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：Foo bar = new Foo(1);bar.method2(); 总结： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 static&#123;&#125;静态代码块与&#123;&#125;非静态代码块(构造代码块) 相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 修正 issue #677：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 Class.forName(&quot;ClassDemo&quot;)创建 Class 对象的时候也会执行。 一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. Example： 12345678910111213141516171819202122232425262728public class Test &#123; public Test() &#123; System.out.print(&quot;默认构造方法！--&quot;); &#125; //非静态代码块 &#123; System.out.print(&quot;非静态代码块！--&quot;); &#125; //静态代码块 static &#123; System.out.print(&quot;静态代码块！--&quot;); &#125; private static void test() &#123; System.out.print(&quot;静态方法中的内容! --&quot;); &#123; System.out.print(&quot;静态方法中的代码块！--&quot;); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); Test.test();//静态代码块！--静态方法中的内容! --静态方法中的代码块！-- &#125;&#125; 上述代码输出： 1静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test.test(); 时输出： 1静态代码块！--静态方法中的内容! --静态方法中的代码块！-- 当只执行 Test test = new Test(); 时输出： 1静态代码块！--非静态代码块！--默认构造方法！-- 非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java常用关键字","slug":"Java常用关键字","permalink":"http://jmiin.github.io/tags/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"集合概览","slug":"2020-09-01-集合","date":"2020-08-31T16:00:00.000Z","updated":"2020-09-03T07:04:25.169Z","comments":true,"path":"2020/09/01/2020-09-01-集合/","link":"","permalink":"http://jmiin.github.io/2020/09/01/2020-09-01-%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java集合","slug":"Java基础/Java集合","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://jmiin.github.io/tags/Java%E9%9B%86%E5%90%88/"}]},{"title":"奋斗者的人生才是幸福的人生!","slug":"2020-06-16-重新启程","date":"2020-06-15T16:00:00.000Z","updated":"2020-09-11T01:48:03.942Z","comments":true,"path":"2020/06/16/2020-06-16-重新启程/","link":"","permalink":"http://jmiin.github.io/2020/06/16/2020-06-16-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B/","excerpt":"","text":"1234567891011121314151617181920生活就像一面镜子你赠予它微笑，它回馈你美貌 你充斥着怒气，它回馈你丑陋当生活像一首歌那样轻快流畅时笑颜常开乃易事而在面对挫折时仍能乐观希望就像灿烂的阳光带着坚定的信念突破重重云层","categories":[{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Mysql简笔","slug":"2017-10-24-Mysql基本使用方法","date":"2017-10-23T16:00:00.000Z","updated":"2020-09-03T07:04:00.293Z","comments":true,"path":"2017/10/24/2017-10-24-Mysql基本使用方法/","link":"","permalink":"http://jmiin.github.io/2017/10/24/2017-10-24-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"启动服务 net start mysql net stop mysql ​ 进入mysql 输入用户名密码。 mysql -u 用户名 -p 如：mysql -u root -p 效果如下： 查看基本命令 每条命令结束后一定要加分号 1.show databases; 查看数据库 2.use 数据库; 选择数据库并使用它 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。 如： 3.show tables; 查看use的数据库的tables（表）; 我这里有下面3个表： 4.select * from 表名; 查看某个表 5.show columns from 表名; 查看某个表中所有字段 以上几个命令是必须掌握的查看命令 SQL语句对MySQL的操作 这里我提前新建好了数据库s_t，建库的方法下面持续会讲。库中有3个表各个表的数据如下： 基本表的定义、删除、与修（略） sql基本了解(注：sql语言不区分大小写） SQL语句之数据查询 基本结构如下：SELECT …FROM …WHERE … 一、 单表查询 1.查询全体学生的学号与姓名。 2.查询出生年月日。 3.消除取值重复的行 关键词distinct 4.聚集函数 where子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having子句。 SQL语句之数据更新一、插入数据 123INSERTINTO &lt;表名&gt; (&lt;属性列1&gt;,&lt;属性列2&gt;,...)VALUES (&#39;常量1&#39;,&#39;常量2&#39;,...) 推荐 如果想更好的了解推荐以下视频 与MySQL的零距离接触","categories":[{"name":"数据库","slug":"数据库","permalink":"http://jmiin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"}]},{"title":"动态规划","slug":"2017-10-24-动态规划","date":"2017-10-23T16:00:00.000Z","updated":"2020-09-04T01:44:20.424Z","comments":true,"path":"2017/10/24/2017-10-24-动态规划/","link":"","permalink":"http://jmiin.github.io/2017/10/24/2017-10-24-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"什么是动态规划（DP）？ DP起源于运筹学，是求解决策过程最优化的数学方法，它一种是将多阶段过程转化为一系列单阶段问题，再利用各阶段之间的关系，逐个求解的方法。即动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。 动态规划干什么用？ 求解决策过程最优化。因此动态规划算法通常用于求解具有某种最优性质的问题。 通常可按以下4个步骤设计： 找出最优解的性质，并刻画其结构特征。 递归地定义最优值。 以自底向上的方式计算出最优解。 根据计算最优值时得到的信息，构造最优解。 动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。 如： 线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等； 区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等； 树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等； 背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶 等； 经典例题01背包问题 问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 如：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。 本题特点是：每种物品仅有一件，可以选择放或不放。 F[i，j]表示在前i个物品中能够装入容量为j的背包中的最大价值。同时设v[i]、w[i]分别为第i个物品的价值和重量，v为背包的容量。 其状态转移方程便是： F[i, v] = maxf&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125; 二维0-1背包问题 给定n种物品和一个背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为c，容积为d。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品只有两个选择：装入或不装入，且不能重复装入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class twobage &#123; public static int maxx(int a, int b) &#123; if (a &gt;= b) return a; else return b; &#125; public static void main(String[] args) &#123; int[] weight = &#123;5,3,8 &#125;; // 物品重量 int[] val = &#123; 7,8,9 &#125;; // 物品价值 int[] b = &#123; 4,6,2 &#125;; int z = 30; // 背包容积 int p, q, i, m = 10; // 背包容量 int n = val.length; // 物品个数 int[][][] f = new int[n + 1][m + 1][z + 1]; // f[i][x][y]表示只允许装前i种物品，背包总重不超过x,物品总体积不超过y时，背包最大价值 int[] path = new int[n + 1]; //下标加1对应物品下标，其值为0代表不放，为1代表放 for (i = 0; i &lt;= n; i++) f[i][0][0] = 0; for (p = 0; p &lt;= m; p++) for (q = 0; q &lt;= z; q++) f[0][p][q] = 0; for (i = 1; i &lt;= n; i++) for (p = 1; p &lt;= m; p++) for (q = 1; q &lt;= z; q++) &#123; if (p &lt; weight[i - 1] || q &lt; b[i - 1]) &#123; f[i][p][q] = f[i - 1][p][q]; &#125;else &#123; f[i][p][q] = maxx(f[i - 1][p][q], f[i - 1][p - weight[i - 1]][q - b[i - 1]] + val[i - 1]); &#125; &#125; p = m; q = z; for (i = n; i &gt;= 1; i--) &#123; if (f[i][p][q] &gt; f[i - 1][p][q]) &#123; path[i] = 1; p = p - weight[i-1]; q = q - b[i-1]; &#125; else path[i] = 0; &#125; System.out.print(&quot;path值：&quot;); for (i = 1; i &lt;= n; i++) System.out.print(path[i] + &quot; &quot;); System.out.println(); System.out.print(&quot;放入的物品为：&quot;); for (i = 1; i &lt;= n; i++) if(path[i]==1) System.out.print(i-1+&quot;号 &quot;); System.out.println(); int r = 0; for (i = 1; i &lt;= n; i++) &#123; if (path[i] == 1) r += val[i - 1]; else r += 0; &#125; System.out.print(&quot;最大价值为：&quot;+r); &#125;&#125; 更多背包问题可以参考背包九讲 动态规划算法的基本要素1. 最优子结构2. 重叠子问题3. 边界4. 子问题独立5. 备忘录方法这里举个简单的例题：动态规划入门-数字三角形 Description 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得 路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //三角形行数。下面是三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 ​ Sample Output 30 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;public class triangle &#123;/* 测试数据：573 88 1 02 7 4 44 5 2 6 5 */ private static int max(int a, int b) &#123; if(a&gt;b) return a; else return b; &#125; public static void main(String[] args) &#123; System.out.print(&quot;请输入行数：&quot;); Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[][] a=new int[n+2][n+2]; int[][] path=new int[n+2][n+2]; int pmax=0; for(int i=0;i&lt;n+2;i++) &#123; a[i][i]=0; &#125; for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt;i;j++) &#123; a[i][j]=(int)sc.nextInt(); &#125; &#125; //输出测试数组 /*for(int i=0;i&lt;=n+1;i++) &#123; for(int j=0;j&lt;i+1;j++) &#123; System.out.print(a[i][j]+&quot; &quot;); &#125;System.out.println(); &#125;*/ for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; path[i][j]=max(path[i-1][j],path[i-1][j-1])+a[i][j]; &#125; &#125; //输出子问题值 for(int i=2;i&lt;n+2;i++) &#123; for(int j=1;j&lt; i;j++) &#123; System.out.print(path[i][j]+&quot; &quot;); if (pmax &lt; path[i][j]) &#123; pmax = path[i][j];//算出最大值 &#125; &#125; System.out.println(); &#125; System.out.println(&quot;最大值为：&quot;+pmax); &#125; &#125; 更多感悟，如果还有下次，再见~","categories":[{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}]},{"title":"单片机","slug":"2017-10-21-T2定时器","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:36.202Z","comments":true,"path":"2017/10/21/2017-10-21-T2定时器/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-T2%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"实验三思考题： 若系统时钟频率为12MHz，编写软件实现：按一下K键，产生一次外部中断1中断信号，启动T2定时，使P1.1输出周期为2秒的方波。 定时器T2,reg52.h没有T2MOD寄存器,regx55.h有T2MOD寄存器而且sbit已经定义。因此头文件用reg55.h。 参考代码:123456789101112131415161718192021222324252627#include &lt;regx55.h&gt;#define uint unsigned int#define uchar unsigned intsbit P11&#x3D;P1^1;uchar num&#x3D;0;void main()&#123; T2MOD&#x3D;0x00; TH2&#x3D;(65536-50000)&#x2F;256; TL2&#x3D;(65536-50000)%256; RCAP2H&#x3D;(65536-50000)&#x2F;256; RCAP2L&#x3D;(65536-50000)%256; IE&#x3D;0xa4; while(1)&#123; if(TF2)&#123; num++; TF2&#x3D;0; &#125; if(num&#x3D;&#x3D;20)&#123; P11&#x3D;~P11; num&#x3D;0; &#125; &#125;&#125;void INTer1() interrupt 2&#123; TR2&#x3D;1;&#125; 因为简单，所以没有注释。 运行结果： 代码工程及仿真","categories":[{"name":"大学时光","slug":"大学时光","permalink":"http://jmiin.github.io/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"Jekyll","slug":"2017-10-21-jekyll","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:23.146Z","comments":true,"path":"2017/10/21/2017-10-21-jekyll/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-jekyll/","excerpt":"","text":"Jekyll Jekyll网站的目录结构。 . ├── _config.yml ├── _data | └── members.yml ├── _drafts | ├── begin-with-the-crazy-ideas.md | └── on-simplicity-in-technology.md ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | └── post.html ├── _posts | ├── 2007-10-29-why-every-programmer-should-play-nethack.md | └── 2009-04-26-barcamp-boston-4-roundup.md ├── _sass | ├── _base.scss | └── _layout.scss ├── _site ├── .jekyll-metadata └── index.html # can also be an &#39;index.md&#39; with valid YAML Frontmatter test2 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 原文链接","categories":[{"name":"暂未分类","slug":"暂未分类","permalink":"http://jmiin.github.io/categories/%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}]},{"title":"递归的时间复杂度","slug":"2017-10-21-递归树","date":"2017-10-20T16:00:00.000Z","updated":"2020-09-03T07:03:48.324Z","comments":true,"path":"2017/10/21/2017-10-21-递归树/","link":"","permalink":"http://jmiin.github.io/2017/10/21/2017-10-21-%E9%80%92%E5%BD%92%E6%A0%91/","excerpt":"","text":"Master定理 有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的： 设常数a &gt;= 1，b &gt; 1，f(n)为函数，T(n)为非负整数，T(n) = a T(n / b) + f(n)，则有： 递归树没事间写QAQ………","categories":[{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"}]},{"title":"The Rose","slug":"2017-10-20-rose","date":"2017-10-19T16:00:00.000Z","updated":"2020-09-03T07:02:12.758Z","comments":true,"path":"2017/10/20/2017-10-20-rose/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-rose/","excerpt":"","text":"The Rose Some say love it is a river That drowns the tender reed Some say love it is a razor That leaves your soul to bleed Some say love it is a hunger An endless aching need I say love it is a flower And you , its only seed It&#39;s the heart afraid of breaking That never learns to dance It&#39;s the dream afraid of waking That never takes the chance It&#39;s the one who won&#39;t be taken Who cannot seem to give And the soul afraid of dying That never learns to live When the night has been too lonely And the road has been too long And you think that love is only For the lucky and the strong Just remember in the winter Far beneath the bitter snows Lies the seed that with the sun&#39;s love In the spring becomes the rose","categories":[{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"假如生活欺骗了你","slug":"2017-10-20-假如生活欺骗了你","date":"2017-10-19T16:00:00.000Z","updated":"2020-09-03T07:02:59.934Z","comments":true,"path":"2017/10/20/2017-10-20-假如生活欺骗了你/","link":"","permalink":"http://jmiin.github.io/2017/10/20/2017-10-20-%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/","excerpt":"","text":"假如生活欺骗了你 《假如生活欺骗了你》是俄国诗人普希金于1825年流放南俄敖德萨同当地总督发生冲突后，被押送到其父亲的领地米哈伊洛夫斯科耶村幽禁期间创作的一首诗歌。诗歌全文表述了一种积极乐观而坚强的人生态度，并且因它亲切和蔼的口气让许多人把它记于自己的笔记本上，成为了激励自己勇往直前，永不放弃的座右铭。 If by Life You Were Deceived If by life you were deceived, Don&#39;t be dismal,don&#39;t be wild! In the day of grief,be mild: Merry days will come,believe. Heart is living in tomorrow; Present is dejected here: In a moment,passes sorrow; That which passes will be dear. 假如生活欺骗了你 假如生活欺骗了你， 不要悲伤，不要心急！ 忧郁的日子里须要镇静： 相信吧，快乐的日子将会来临！ 心儿永远向往着未来； 现在却常是忧郁。 一切都是瞬息，一切都将会过去； 而那过去了的，就会成为亲切的怀恋。","categories":[{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Hello,world!","slug":"2017-10-19-你好世界","date":"2017-10-18T16:00:00.000Z","updated":"2020-09-11T01:51:49.854Z","comments":true,"path":"2017/10/19/2017-10-19-你好世界/","link":"","permalink":"http://jmiin.github.io/2017/10/19/2017-10-19-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","excerpt":"","text":"Hey Hello World 中文意思是『世界，你好』。因为《The C Programme Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。 Java12345678package text1;public class A &#123; public static void main(String[] args) &#123; System.out.printf(&quot;hello,world!&quot;); &#125;&#125; C123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125; VB12345Module MainFrm Sub Main() System.Console.WriteLine(&quot;Hello, World!&quot;) End SubEnd Module Python31print(&quot;Hello, World!&quot;) Ruby123def hello() return &quot;Hello , World&quot; end JavaScript1console.log(&quot;Hello, World!&quot;) C++1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;flush; return 0;&#125;","categories":[{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发原理","slug":"多线程/并发原理","permalink":"http://jmiin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jmiin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"设计模式/单例模式","permalink":"http://jmiin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"http://jmiin.github.io/categories/Spring/"},{"name":"AOP","slug":"Spring/AOP","permalink":"http://jmiin.github.io/categories/Spring/AOP/"},{"name":"Java基础","slug":"Java基础","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Java集合","slug":"Java基础/Java集合","permalink":"http://jmiin.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"},{"name":"新生","slug":"新生","permalink":"http://jmiin.github.io/categories/%E6%96%B0%E7%94%9F/"},{"name":"数据库","slug":"数据库","permalink":"http://jmiin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://jmiin.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"大学时光","slug":"大学时光","permalink":"http://jmiin.github.io/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/"},{"name":"暂未分类","slug":"暂未分类","permalink":"http://jmiin.github.io/categories/%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"诗歌","slug":"诗歌","permalink":"http://jmiin.github.io/categories/%E8%AF%97%E6%AD%8C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://jmiin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"单例模式","slug":"单例模式","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"http://jmiin.github.io/tags/Spring/"},{"name":"Java常用关键字","slug":"Java常用关键字","permalink":"http://jmiin.github.io/tags/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"Java集合","slug":"Java集合","permalink":"http://jmiin.github.io/tags/Java%E9%9B%86%E5%90%88/"},{"name":"生活","slug":"生活","permalink":"http://jmiin.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Mysql","slug":"Mysql","permalink":"http://jmiin.github.io/tags/Mysql/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://jmiin.github.io/tags/Algorithms/"},{"name":"单片机","slug":"单片机","permalink":"http://jmiin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"科技","slug":"科技","permalink":"http://jmiin.github.io/tags/%E7%A7%91%E6%8A%80/"}]}