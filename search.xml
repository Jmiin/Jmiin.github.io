<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>How did say goodbye?</title>
      <link href="2020/10/19/2018-10-19-%E5%86%8D%E8%A7%81/"/>
      <url>2020/10/19/2018-10-19-%E5%86%8D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>嘿 siri</p><p>Hey siri</p><p>该如何跟你不想失去的人说再见?</p><p>How do u say goodbye to someone you can’t imagine living without?</p><p>siri: 这个问题太难回答</p><p>siri: The question is too difficult to answer</p><p>siri:你会说什么？</p><p>siri: What would  you say?</p><p>我没说再见</p><p>I didn’t say goodbye</p><p>我什么也没说</p><p>I didn’t say anything</p><p>我就这么离开了</p><p>I just walked away</p><p>siri: 你还难过吗？</p><p>siri: Are you still feeling sad?</p><p>当然</p><p>of course</p><p> 但是你知道</p><p>but you know</p><p>并非每场相遇都会有结果</p><p>Not every encounter has an end</p><p>但是每场相遇都会有意义</p><p>But each meeting carries some meanings</p><p>siri: 是的，有些人的出现教会了你成长</p><p>siri: Yes, some people are there to help you grow</p><p>I wish you happiness.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 新生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发底层实现原理</title>
      <link href="2020/09/12/2020-09-12-%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/12/2020-09-12-%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java代码编译后形成字节码文件，字节码被类加载器加载到JVM中，JVM将字节码转换为汇编指令在CPU上执行，整个过程并发机制的实现全部依赖于JVM和CPU的指令。</p></blockquote><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>JMM存在一个主线程，每个线程有自己的私有的本地内存，本地内存中保存了一些共享变量的拷贝。</p><p>为了保证当一个线程修改了共享变量是，另一个线程可以读取到这个修改后的值(即保证内存可见性)，引入了volatile关键字。</p></blockquote><h4 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h4><p>1、保证共享变量的<strong>内存可见性</strong>。</p><p>2、禁止volatile变量与普通变量重排序。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="CAS与原子操纵"><a href="#CAS与原子操纵" class="headerlink" title="CAS与原子操纵"></a>CAS与原子操纵</h3>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> 并发原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2020/09/11/2020-09-11-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/09/11/2020-09-11-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 单例模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="2020/09/10/2020-09-10-AOP/"/>
      <url>2020/09/10/2020-09-10-AOP/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="2020/09/09/2020-09-09-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/09/09/2020-09-09-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在并发编程中，需要注意两个关键问题： </p><blockquote><p>线程间如何通信? 即: 线程间以何种机制来交换信息.</p><p>线程间如何同步? 即: 线程间以何种机制来控制不同线程间操作发生的相对顺序.</p></blockquote><p> 在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p></blockquote><h3 id="两种内存模型比较"><a href="#两种内存模型比较" class="headerlink" title="两种内存模型比较"></a>两种内存模型比较</h3><table><thead><tr><th align="center">模型</th><th align="center">如何通信</th><th align="center">如何同步</th></tr></thead><tbody><tr><td align="center">共享内存</td><td align="center">线程之间共享内存的公共状态，通过写-读内存中的公共状态进行隐式的通信。</td><td align="center">同步是显式进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。</td></tr><tr><td align="center">消息传递</td><td align="center">线程之间没有公共状态，线程之间必须通过发送消息来显式的通信。</td><td align="center">由于消息的发送必须在消息接收之前，因此同步是隐式执行的。</td></tr></tbody></table><p><strong>Java的并发采用的是共享内存模型，它的线程之间的通信总是隐式执行的。</strong></p><h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><h4 id="运行时内存的划分"><a href="#运行时内存的划分" class="headerlink" title="运行时内存的划分"></a>运行时内存的划分</h4><p>先看下运行时数据区：</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/JVM-struct.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/JVM-struct.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Java运行时的数据区"></p><p>堆在线程间是共享的，而所有的实例域、静态域和数组元素等变量都存储在堆内存（这些元素统一被称为<strong>共享变量</strong>）。而栈中的变量（局部变量、方法定义的参数、异常处理器的参数等）不会在线程之间共享，也就不会存在 <strong><em>内存可见性</em></strong> 。内存可见性针对的是共享变量。</p><h3 id="堆的内存不可见问题"><a href="#堆的内存不可见问题" class="headerlink" title="堆的内存不可见问题"></a>堆的内存不可见问题</h3><p>现代计算机为了高效，会在高速缓存区中缓存共享变量，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，它存储了该线程以读、写共享变量的拷贝（副本）。本地内存是JMM的一个抽象的概念，并不真实存在。</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/JMM-abstruct-struct.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/JMM-abstruct-struct.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Java内存模型的抽象结构示意图"></p><p>从图中可以看出：</p><ul><li>所有的共享变量都存储在主内存中。</li><li>每个线程都保留了一份该线程使用到了的共享变量的拷贝。</li><li>如果A与B两个线程进行通信的话，需要经过以下两个步骤:<ul><li>A将本地内存中被更新过的共享变量副本刷新到主内存中。</li><li>B需要到主内存中去读取A之前已经更新过的共享变量。</li></ul></li></ul><p>整个过程中A、B是无法之间访问对方的工作内存的，<strong>线程之间的通信必须经过主内存</strong>。</p><p>注意：根据JMM的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。</strong></p><p>因此B并不是直接到主内存读取共享变量的值，而是先在本地内存中找到这个共享变量，发现这个共享变量已经被更新了，然后B去主内存中读取这个共享变量的新值，并拷贝到B的本地内存中，最后B在从本地内存读取新值。</p><pre><code>JMM正是通过控制主内存与每个线程的本地内存之间的交互来为Java程序员提供内存可见性的保证。</code></pre><blockquote><p>Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅可以保证可见性，同时也可以保证原子性。</p></blockquote><h3 id="指令的重排序"><a href="#指令的重排序" class="headerlink" title="指令的重排序"></a>指令的重排序</h3><blockquote><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p><p>1、编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2、指令级并行的重排序：多条指令不存在数据依赖时，处理器可以改变语句对应机器指令的执行顺序。</p><p>3、内存系统的重排序。</p><blockquote><p>从源码到最终的执行序列会按上述顺序进行重排序。</p></blockquote></blockquote><p>这些重排序很可能导致多线程程序出现<strong>内存可见性</strong>的问题。</p><p>对于编译器，JMM规定<strong>会禁止特定类型的编译器重排序</strong>。</p><p>对于处理器，JMM规定**在生成指令序列时，插入特定类型的内存屏障（Memory Barriers）指令，通过它来禁止。</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/Memory-Barriers-types.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/Memory-Barriers-types.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="内存屏障的类型"></p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><blockquote><p>Java内存模型使用happens-before的概念来描述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</p><blockquote><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B且B happens-before C，那么A happens-before C。  </li><li>start规则：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作。</li><li>join规则：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。  </li></ul></blockquote></blockquote><pre><code>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。  </code></pre><blockquote><p><strong><em>通俗的讲，happens-before可以理解为发生在某某之前，其主要是为了体现程序执行的顺序性，而这种顺序性保证了JMM的内存可见性。</em></strong></p></blockquote><h3 id="JMM与Java内存区域"><a href="#JMM与Java内存区域" class="headerlink" title="JMM与Java内存区域"></a>JMM与Java内存区域</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>两者是不同的概念层次，JMM是抽象的，是用来描述一组规则，通过这个规则实现了线程的通信和同步。</p><p>而Java运行时的内存的划分是具象的，是JVM运行Java程序时，必要的内存划分。</p><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>都存在私有的数据区域和共享数据区域。</p><ul><li>JMM中主内存属于共享数据区域，包含堆和方法区。</li><li>JMM中本地内存属于私有数据区域，包含了程序计数器、本地方法区、虚拟机栈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="2020/09/08/2020-09-08-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>2020/09/08/2020-09-08-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每一个线程都有其自己的私有上下文，当多个线程需要共同合作完成某项任务时，两者必定是会产生通信，而线程间的通信完全围绕它们共同持有的资源进行的。</p></blockquote><h3 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程组及线程优先级</title>
      <link href="2020/09/07/2020-09-07-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>2020/09/07/2020-09-07-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote><p>线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统⼀控制线程的优先级和检查线程的权限的作用。  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent; <span class="comment">// ⽗亲ThreadGroup</span></span><br><span class="line">    String name; <span class="comment">// ThreadGroupr 的名称</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority; <span class="comment">// 线程最大优先级</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed; <span class="comment">// 是否被销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon; <span class="comment">// 是否守护线程</span></span><br><span class="line">    <span class="keyword">boolean</span> vmAllowSuspension; <span class="comment">// 是否可以中断</span></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>; <span class="comment">// 还未启动的线程</span></span><br><span class="line">    <span class="keyword">int</span> nthreads; <span class="comment">// ThreadGroup中线程数目</span></span><br><span class="line">    Thread threads[]; <span class="comment">// ThreadGroup中的线程</span></span><br><span class="line">    <span class="keyword">int</span> ngroups; <span class="comment">// 线程组数目</span></span><br><span class="line">    ThreadGroup groups[]; <span class="comment">// 线程组数组</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>线程组可以包含线程也可以包含其它线程组</strong></p><p>如果在<code>new Thread()</code>时没有显示的指定线程的线程组，那么默认将它的父线程的线程组设置为自己的线程组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;的线程组的名字为：&quot;</span></span><br><span class="line">                            + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程的线程组的名字为：&quot;</span></span><br><span class="line">                        + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">main线程的线程组的名字为：main</span><br><span class="line">当前线程Thread-<span class="number">0</span>的线程组的名字为：main</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><p>线程组基本的常用方法如下</p></blockquote><table><thead><tr><th align="center">返回值</th><th>方法名</th></tr></thead><tbody><tr><td align="center"><code>int</code></td><td><code>activeCount()</code>      返回此线程组中活动线程的估计数。</td></tr><tr><td align="center"><code>int</code></td><td><code>activeGroupCount()</code>      返回此线程组中活动线程组的估计数。</td></tr><tr><td align="center"><code> void</code></td><td><code>checkAccess()</code>      确定当前运行的线程是否有权修改此线程组。</td></tr><tr><td align="center"><code> void</code></td><td><code>destroy()</code>      销毁此线程组及其所有子组。</td></tr><tr><td align="center"><code> int</code></td><td><code>enumerate(Thread[] list)</code>      把此线程组及其子组中的所有活动线程复制到指定数组中。</td></tr><tr><td align="center"><code> int</code></td><td><code>enumerate(Thread[] list, boolean recurse)</code>      把此线程组中的所有活动线程复制到指定数组中。</td></tr><tr><td align="center"><code> int</code></td><td><code>enumerate(ThreadGroup[] list)</code>      把对此线程组中的所有活动子组的引用复制到指定数组中。</td></tr><tr><td align="center"><code> int</code></td><td><code>enumerate(ThreadGroup[] list, boolean recurse)</code>  把对此线程组中的所有活动子组的引用复制到指定数组中。</td></tr><tr><td align="center"><code> int</code></td><td><code>getMaxPriority()</code>     返回此线程组的最高优先级。</td></tr><tr><td align="center"><code> String</code></td><td><code>getName()</code>      返回此线程组的名称。</td></tr><tr><td align="center"><code> ThreadGroup</code></td><td><code>getParent()</code>      返回此线程组的父线程组。</td></tr><tr><td align="center"><code> void</code></td><td><code>interrupt()</code>      中断此线程组中的所有线程。</td></tr><tr><td align="center"><code> boolean</code></td><td><code>isDaemon()</code>      测试此线程组是否为一个守护线程。</td></tr><tr><td align="center"><code> boolean</code></td><td><code>isDestroyed()</code>      测试此线程组是否已经被销毁。</td></tr><tr><td align="center"><code> void</code></td><td><code>list()</code>      将有关此线程组的信息打印到标准输出。</td></tr><tr><td align="center"><code> boolean</code></td><td><code>parentOf(ThreadGroup g)</code>      测试此线程组是否为线程组参数或其祖先线程组之一。</td></tr><tr><td align="center"><code> void</code></td><td><code>setDaemon(boolean daemon)</code>      更改此线程组的后台程序状态。</td></tr><tr><td align="center"><code> void</code></td><td><code>setMaxPriority(int pri)</code>      设置线程组的最高优先级。</td></tr><tr><td align="center"><code>void</code></td><td><code>uncaughtException(Thread t, Throwable e)</code>      当此线程组中的线程因为一个未捕获的异常而停止，并且线程没有设置特定 <code>Thread.uncaughtExceptionHandler</code>时，由 Java Virtual Machine 调用此方法。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">其中uncaughtExceptionHandler为线程池捕获线程成员的异常接口</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testUncatchException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadGroup threadGroup1 = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;group1&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 继承ThreadGroup并重新定义以下方法</span></span><br><span class="line">            <span class="comment">// 在线程成员抛出unchecked exception</span></span><br><span class="line">            <span class="comment">// 会执行此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 这个线程是threadGroup1的⼀员</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(threadGroup1, ()-&gt; &#123;</span><br><span class="line">                <span class="comment">// 抛出unchecked异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;测试异常&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"> &#125;</span><br><span class="line">运行结果：</span><br><span class="line">Thread-<span class="number">0</span>: 测试异常 </span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><blockquote><p>线程中的优先级由低到高指定范围为1~10，默认为5，但是线程执行的本质还有由CPU的调度来决定的，只是通常情况下高优先级的线程更有可能被分配到资源优先执行。</p><p>Java提供一个线程调度器来监视和控制处于Runnable状态的线程。其调度方式是抢占式的，在相同优先级的情况下按照”先到先得”的原则进行。</p><blockquote><p>守护线程（Deamon)：</p><p>守护线程的优先级比较低，某线程是守护线程，如果其它所有的非守护线程结束，这个守护线程也会自动结束。这样的操作可以免去关闭子线程的麻烦。</p><p>线程默认是非守护线程，可以通过Thread类中的setDeamon(boolean on)来设置。</p></blockquote></blockquote><hr><p>线程和线程组都存在优先级，如果属于该线程组的线程的优先级和它的线程组的优先级不一样会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">diffPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        threadGroup.setMaxPriority(<span class="number">6</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadGroup, <span class="string">&quot;thread&quot;</span>);</span><br><span class="line">        thread.setPriority(<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程组的优先级&quot;</span> + threadGroup.getMaxPriority());</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程的优先级&quot;</span> + thread.getPriority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">我是线程组的优先级<span class="number">6</span></span><br><span class="line">我是线程的优先级<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>所以，如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。</strong>  </p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程实现及创建方式</title>
      <link href="2020/09/06/2020-09-06-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
      <url>2020/09/06/2020-09-06-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     * 初始状态，线程被构建，但是还没有调用start()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     * 运行状态，Java线程将操作系统中的就绪和运行状态笼统的称作：运行中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">    * 阻塞状态，表示线程阻塞于锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     * 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定的动作</span></span><br><span class="line"><span class="comment">     *(通知或中断)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * 超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     * 终止状态，表示当前线程已经执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程并不是始终固定于某一个状态而是随着代码的执行在不同状态之间进行切换的。</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-status-convert.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-status-convert.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><h3 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><blockquote><p>继承 Thread 类，并重写 run ⽅法；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建⼀个线程，然后等到这个线程第⼀次得到时间片时再调⽤run()方法。 注意不可多次调用start()方法。在第⼀次调start()方法后，再次调用start() 方法会抛出异常</p></blockquote><hr><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><blockquote><p>接着我们来看⼀下 Runnable 接⼝(JDK 1.8 +)：  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个经典的函数式接口，这意味着我们可以使用Java 8 的<a href="">函数式编程</a>来简化代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplRunnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态代理的方式实现线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;Impl Runnable Thread&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>new Thread(Runnable target)</code>本质上是使用<a href="">静态代理</a>的方式实现的。</p></blockquote><h5 id="Thread类构造方法"><a href="#Thread类构造方法" class="headerlink" title="Thread类构造方法"></a>Thread类构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段1 - init⽅法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize,AccessControlContext acc,<span class="keyword">boolean</span> inheritThreadLocals)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// ⽚段2 - 构造函数调⽤init⽅法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段3 - 使⽤在init⽅法⾥初始化AccessControlContext类型的私有属性</span></span><br><span class="line"><span class="keyword">this</span>.inheritedAccessControlContext = acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段4 - 两个对⽤于⽀持ThreadLocal的私有属性</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Thread类的几个常用的方法"><a href="#Thread类的几个常用的方法" class="headerlink" title="Thread类的几个常用的方法"></a>Thread类的几个常用的方法</h5><ul><li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li><li>start()：开始执行线程的方法，java虚拟机会调⽤线程内的run()方法；</li><li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调⽤了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li><li>sleep()：静态方法，使当前线程睡眠⼀段时间；</li><li>join()：使当前线程等待另⼀个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li></ul><h5 id="Thread类与Runnable接口的比较"><a href="#Thread类与Runnable接口的比较" class="headerlink" title="Thread类与Runnable接口的比较"></a>Thread类与Runnable接口的比较</h5><p>实现⼀个自定义的线程类，可以有继承 Thread 类或者实现 Runnable 接⼝这两种方式，它们之间有什么优劣呢？</p><ul><li>由于Java“单继承，多实现”的特性，Runnable接口使⽤起来比Thread更灵活。</li><li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li><li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li><li>如果使用线程时不需要使⽤Thread类的诸多⽅法，显然使用Runnable接口更为轻量。</li></ul><p>所以，我们通常优先使用“实现 Runnable 接口”这种方式来自定义线程类  </p><hr><h4 id="Callable接口、Future接口"><a href="#Callable接口、Future接口" class="headerlink" title="Callable接口、Future接口"></a>Callable接口、Future接口</h4><blockquote><p>使用以上两种方式创建的线程是无返回值的。而有时候我们希望开启线程去执行某项任务时能动态的返回执行完毕后的结果。</p><p>JDK提供了 Callable 接口与 Future 类为我们解决这个问题，这也是所谓的“异步”模型。  </p></blockquote><h5 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Callable</code>接口一般是配合线程池工具<code>ExecutorService</code>来使用的。通过<code>submit()</code>方法让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code>。通过<code>Future</code>的<code>get</code>方法可以得到执行结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Impl Callable&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是演示使用该方法，正常情况下是不允许的</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        ImplCallable implCallable = <span class="keyword">new</span> ImplCallable();</span><br><span class="line">        Future&lt;String&gt; submit = executorService.submit(implCallable);</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 运行结果：</span></span><br><span class="line"><span class="comment">* Impl Callable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="#pool"> 注意：阿里巴巴开发手册：线程池不允许使用 Executors 去创建</a>后文会提到。</p><h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//试图取消一个线程的执行，返回是否取消成功</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//判断当前方法是否取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断当前方法是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//多等待timeout的时间就会返回结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般Future是和线程池搭配使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Future和ExecutorService搭配使用</span></span><br><span class="line"><span class="comment"> * 运行程序的主机是12线程的，因此启动了12个线程，每次会同时执行12个task。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类声明</span></span><br><span class="line">        Callable&lt;Long&gt; callable = <span class="keyword">new</span> Callable&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> seed = end - start;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; seed=&quot;</span> + seed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> seed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Callable&lt;Long&gt;&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环添加24次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">            tasks.add(callable);</span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//判断计算机的线程</span></span><br><span class="line">        <span class="keyword">int</span> poolSize = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(<span class="string">&quot;poolSize=&quot;</span> + poolSize);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">        List&lt;Future&lt;Long&gt;&gt; futures = executorService.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">            result += future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：    poolSize=12    pool-1-thread-8 seed=100    pool-1-thread-4 seed=100    pool-1-thread-2 seed=100    pool-1-thread-3 seed=100    pool-1-thread-7 seed=100    pool-1-thread-5 seed=100    pool-1-thread-1 seed=100    pool-1-thread-6 seed=100    pool-1-thread-9 seed=100    pool-1-thread-10 seed=100    pool-1-thread-11 seed=100    pool-1-thread-12 seed=100    pool-1-thread-9 seed=101    pool-1-thread-1 seed=101    pool-1-thread-3 seed=101    pool-1-thread-10 seed=101    pool-1-thread-12 seed=101    pool-1-thread-11 seed=101    pool-1-thread-8 seed=101    pool-1-thread-4 seed=101    pool-1-thread-2 seed=101    pool-1-thread-7 seed=101    pool-1-thread-5 seed=101    pool-1-thread-6 seed=101    result=2412</code></pre><hr><h4 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a><span id="pool">基于线程池的方式</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">池化技术相信大家已经屡见不鲜了，线程池、数据库连接池、 Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</span><br></pre></td></tr></table></figure><h5 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h5><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h5 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h5><p>《阿里巴巴Java开发手册》中强制线程池不允许使用<code>Executors </code>去创建，而是通过<code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 。</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-rule-alibaba-01.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-rule-alibaba-01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="《阿里巴巴Java开发手册-嵩山版》"></p><p><code>ThreadPoolExecutor  </code>类提供了4个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。以上3个构造方法都是建立在这个基础上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure><hr><p><strong><code>ThreadPoolExecutor</code>构造函数重要参数分析</strong><br>    <code>ThreadPoolExecutor</code> 3个最重要的参数：</p><ul><li>corePoolSize: 核心线程数线程数定义了最小可以同时运行的线程数量。</li></ul><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会⼀直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote><ul><li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li></ul><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote><ul><li>workQueue :阻塞队列， 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他参数：</p><ul><li><p><code>keepAliveTime</code>: <strong>非核心线程闲置超时时长。</strong>当线程池中的线程数量大于<code>corePoolSize</code>的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了<code>keepAliveTime</code>才会被回收销毁；</p></li><li><p><code>unit</code>: 上面参数的时间单位。</p><blockquote><p>unit是⼀个枚举类型 ，包括以下属性：</p><ul><li>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 </li><li>MICROSECONDS ： 1微秒 = 1毫秒 / 1000 </li><li>MILLISECONDS ： 1毫秒 = 1秒 /1000 </li><li>SECONDS ： 秒</li><li>MINUTES ： 分 </li><li>HOURS ： 小时 </li><li>DAYS ： 天  </li></ul></blockquote><ul><li><code>threadFactory</code>: 创建线程的⼯⼚ ，⽤于批量创建线程，统⼀在创建线程时设置⼀些参数，如是<br>否守护线程、线程的优先级等。如果不指定，会新建⼀个默认的线程工厂</li></ul></li><li><p><code>handler</code>：饱和策略。</p></li></ul><blockquote><p>饱和策略：</p><blockquote><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code>定义一些策略：</p><p><code>RejectedExecutionHandler</code>具体的实现类有4种:</p><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/RejectedExecutionHandler_2020-09-08_15-51-31.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/RejectedExecutionHandler_2020-09-08_15-51-31.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="RejectedExecutionHandler实现类"></p><p>可以参考这4个实体类的源码，饱和后的操作都是实现<code>rejectedExecution(Runnable r,ThreadPoolExecutor executor)</code>方法 ，它们都是<code>ThreadPoolExecutor</code> 的静态内部类：</p><ol><li>ThreadPoolExecutor.AbortPolicy ：抛出 RejectedExecutionException 来拒绝新任<br>务的处理 。</li><li>ThreadPoolExecutor.CallerRunsPolicy ：简单点说就是后面<strong>排队</strong>的线程就在那儿等着。调用执行当前传入的线程进行运行。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果应用程序可以承受此延迟并且不能丢弃任何⼀个任务请求的话，你可以选择这个策略。  </li><li>ThreadPoolExecutor.DiscardPolicy ： 不处理新任务，直接丢弃掉。  </li><li>ThreadPoolExecutor.DiscardOldestPolicy ： 此策略将丢弃最早的未处理的任务请求。  </li></ol></blockquote></blockquote><hr><h5 id="线程池主要的任务处理流程-重要"><a href="#线程池主要的任务处理流程-重要" class="headerlink" title="线程池主要的任务处理流程 (重要)"></a>线程池主要的任务处理流程 (重要)</h5><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/threadPool-shiyi-imag.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/threadPool-shiyi-imag.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="线程池执行示意图"></p><p>当线程池接收到一个任务时，主要是通过源码中的<code>execute()</code>方法去执行的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">// 1.当前线程数⼩于corePoolSize,则调⽤addWorker创建核⼼线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果不⼩于corePoolSize，则将任务添加到workQueue队列。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行饱和策略。</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">           reject(command);</span><br><span class="line">            <span class="comment">// 2.2 线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果放⼊workQueue失败，则创建非核⼼线程执⾏任务，</span></span><br><span class="line">        <span class="comment">// 如果这时创建非核⼼线程失败(当前线程总数不⼩于maximumPoolSize时)，就会执行饱和策略。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>主要分为3步：</p><p>1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3、线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p></blockquote><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-0101.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-0101.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>实例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大核心线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXINUM_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 最大队列长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 非核心线程闲置超时时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,</span><br><span class="line">                MAXINUM_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行</span></span><br><span class="line">        <span class="comment">//任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt;corePoolSize时）。</span></span><br><span class="line">        <span class="comment">// 注意，这一步需要获得全局锁。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然</span></span><br><span class="line">        <span class="comment">//后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行</span></span><br><span class="line">        <span class="comment">//这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得</span></span><br><span class="line">        <span class="comment">//全局锁。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的</span></span><br><span class="line">        <span class="comment">//饱和策略进行处理。</span></span><br><span class="line">        <span class="comment">//最大任务数</span></span><br><span class="line">        <span class="keyword">int</span> maxTask = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxTask; i++) &#123;</span><br><span class="line">           Runnable task = ()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start.Time = &quot;</span> +<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End.Time = &quot;</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行Runnable</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 当maxTask小于缓存队列的长度时(如：maxTask = 10)，线程池不需要创建非核心线程来处理任务    运行结果：    pool-1-thread-2 Start.Time = 09:25:19    pool-1-thread-3 Start.Time = 09:25:19    pool-1-thread-5 Start.Time = 09:25:19    pool-1-thread-4 Start.Time = 09:25:19    pool-1-thread-1 Start.Time = 09:25:19    pool-1-thread-1 End.Time = 09:25:21    pool-1-thread-2 End.Time = 09:25:21    pool-1-thread-4 End.Time = 09:25:21    pool-1-thread-3 End.Time = 09:25:21    pool-1-thread-5 End.Time = 09:25:21    pool-1-thread-4 Start.Time = 09:25:21    pool-1-thread-3 Start.Time = 09:25:21    pool-1-thread-2 Start.Time = 09:25:21    pool-1-thread-1 Start.Time = 09:25:21    pool-1-thread-5 Start.Time = 09:25:21    pool-1-thread-3 End.Time = 09:25:23    pool-1-thread-5 End.Time = 09:25:23    pool-1-thread-1 End.Time = 09:25:23    pool-1-thread-2 End.Time = 09:25:23    pool-1-thread-4 End.Time = 09:25:23    Process finished with exit code 02. 当maxTask大于缓存队列的长度时(如：maxTask = 210)，线程池不需要创建非核心线程来处理任务    运行结果为：    pool-1-thread-10 Start.Time = 09:26:56    pool-1-thread-7 Start.Time = 09:26:56    pool-1-thread-1 Start.Time = 09:26:56    pool-1-thread-9 Start.Time = 09:26:56    pool-1-thread-8 Start.Time = 09:26:56    pool-1-thread-2 Start.Time = 09:26:56    pool-1-thread-4 Start.Time = 09:26:56    pool-1-thread-6 Start.Time = 09:26:56    main Start.Time = 09:26:56    pool-1-thread-3 Start.Time = 09:26:56    pool-1-thread-5 Start.Time = 09:26:56    pool-1-thread-5 End.Time = 09:26:58    pool-1-thread-3 End.Time = 09:26:58    pool-1-thread-1 End.Time = 09:26:58    pool-1-thread-6 End.Time = 09:26:58    pool-1-thread-9 End.Time = 09:26:58    ......</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="2020/09/05/2020-09-05-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/09/05/2020-09-05-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程基本概念"><a href="#进程与线程基本概念" class="headerlink" title="进程与线程基本概念"></a>进程与线程基本概念</h2><blockquote><p>一切都是为了提高系统资源利用率，提高系统吞吐量而生。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最初的时候的计算机完全由用户输入的指令控制执行，当用户停止时，计算机也会停止。这样效率及其低下。尽管后面出来的批处理系统可以将指令形成一套连续的流程对计算机进行控制，但是运行方式  <strong>仍然是串行的，内存中永远都是只有一个程序在运行</strong>，所以批处理效率也并不高。 </p><p>内存完全是可以存在多个程序同时进行的。于是，进程由此诞生，进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的，各个进程之间互相不干扰。同时进程保存着程序每一个时刻运行的状态。</p><pre><code>    此时，CPU采用时间片轮询的方式运行进程：如果时间片结束进程还没有执行完毕，则暂停这个进程的运行，并且把CPU分配给其他的进程，这个过程就叫做上下文切换。    它的出现让操作系统的并发成为了可能，虽然并发从宏观上看有多个任务在执⾏，但在事实上，对于单核CPU来说，任意具体时刻都只有⼀个任务在占⽤CPU资源。  </code></pre><h3 id="线程的提出"><a href="#线程的提出" class="headerlink" title="线程的提出"></a>线程的提出</h3><p>进程的出现并不能让人们满足，如果⼀个进程有多个⼦任务时，只能逐个得执行这些子任务，很影响效率。为了同时让这些子任务同时执行，于是线程的提出变成了理所当然，<strong>每个线程负责一个单独的子任务</strong>。</p><blockquote><p>线程与进程相似，但线程是⼀个⽐进程更小的执⾏单位。⼀个进程在其执⾏的过程中可以产生多个线<br>程。与进程不同的是同类的多个线程共享同⼀块内存空间和⼀组系统资源，所以系统在产生⼀个线程，<br>或是在各个线程之间作切换⼯作时，负担要⽐进程小得多，也正因为如此，线程也被称为轻量级进程。   </p></blockquote><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-number.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/thread-number.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="一个进程拥有多个线程"></p><hr><h4 id="多线程实现并发的好处"><a href="#多线程实现并发的好处" class="headerlink" title="多线程实现并发的好处"></a>多线程实现并发的好处</h4><p>1.进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。<br>2.进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。  </p><h4 id="两者之间的区别"><a href="#两者之间的区别" class="headerlink" title="两者之间的区别"></a>两者之间的区别</h4><p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。它们本质的区别是<strong>是否单独占有内存地址空间及其它系统资源</strong>：</p><pre><code>1.进程单独占由一定的内存地址空间，它们之间是存在内存隔离，数据是分开的，数据共享复杂但是同步简单各个进程之间互不干扰；而线程共享所属进程占用的内存地址空间和资源，数据共享简单，但是同步复杂。2.进程单独占有一定的内存地址空间，一个进程出现问题不会影响其它进程，不影响主程序的稳定性，可靠性高；一个线程奔溃可能影响整个程序的稳定性，可靠性低。3.进程单独占有一定的内存地址空间，进程的创建和销毁不仅仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销大；线程只需要保存寄存器和栈信息，开销小。</code></pre><blockquote><p> <strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。</strong></p></blockquote><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>并发： 同⼀时间段，多个任务都在执行 (单位时间内不⼀定同时执行 )。<br>并行： 单位时间内，多个任务同时执行 。  </p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用关键字</title>
      <link href="2020/09/03/2020-09-03-java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/09/03/2020-09-03-java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li><p><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></p></li><li><p><strong>final修饰的方法不能被重写；</strong></p></li><li><p><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></p></li></ol><p>说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p><strong>static 关键字主要有以下四种使用场景：</strong></p><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code>    <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this关键字用于引用类的当前实例。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;Total employees: &quot;</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，this关键字用于两个地方：</p><ul><li>this.employees.length：访问类Manager的当前实例的变量。</li><li>this.report（）：调用类Manager的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code> 方法。</p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li>在构造器中使用 <code>super（）</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><p><strong>简单解释一下：</strong></p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p><h1 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a>static 关键字详解</h1><h2 id="static-关键字主要有以下四种使用场景"><a href="#static-关键字主要有以下四种使用场景" class="headerlink" title="static 关键字主要有以下四种使用场景"></a>static 关键字主要有以下四种使用场景</h2><ol><li>修饰成员变量和成员方法</li><li>静态代码块</li><li>修饰类(只能修饰内部类)</li><li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li></ol><h3 id="修饰成员变量和成员方法-常用"><a href="#修饰成员变量和成员方法-常用" class="headerlink" title="修饰成员变量和成员方法(常用)"></a>修饰成员变量和成员方法(常用)</h3><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p> HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>调用格式：</p><ul><li><code>类名.静态变量名</code></li><li><code>类名.静态方法名()</code></li></ul><p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello i am java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StaticBean&#123;&quot;</span>+</span><br><span class="line">                <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBean staticBean = <span class="keyword">new</span> StaticBean(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        StaticBean staticBean2 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        StaticBean staticBean3 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        StaticBean staticBean4 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        StaticBean.age = <span class="number">33</span>;</span><br><span class="line">        System.out.println(staticBean + <span class="string">&quot; &quot;</span> + staticBean2 + <span class="string">&quot; &quot;</span> + staticBean3 + <span class="string">&quot; &quot;</span> + staticBean4);</span><br><span class="line">        <span class="comment">//StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125;</span></span><br><span class="line">        StaticBean.SayHello();<span class="comment">//Hello i am java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p><p>静态代码块的格式是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;    </span><br><span class="line">语句体;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg" class="lazyload" data-srcset="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p><ol><li>它的创建是不需要依赖外围类的创建。</li><li>它不能使用任何外围类的非static成员变量和方法。</li></ol><p>Example（静态内部类实现单例模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance() </code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><h3 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h3><p>格式为：import static </p><p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span></span><br><span class="line"> <span class="comment">//如果只想导入单一某个静态方法，只需要将换成对应的方法名即可</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//换成import static java.lang.Math.max;具有一样的效果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> max = max(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p><p>Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;An example string that doesn&#x27;t depend on i (an instance variable)&quot;</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.i + <span class="number">1</span>;  <span class="comment">//Depends on i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：<code>Foo bar = new Foo(1);bar.method2();</code></p><p>总结：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 </li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 </li></ul><p><strong><code>static&#123;&#125;</code>静态代码块与<code>&#123;&#125;</code>非静态代码块(构造代码块)</strong></p><p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 </p><p>不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 </p><blockquote><p>修正 <a href="https://github.com/Snailclimb/JavaGuide/issues/677">issue #677</a>：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p></blockquote><p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. </p><p>Example：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;默认构造方法！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;非静态代码块！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态代码块！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态方法中的内容! --&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;静态方法中的代码块！--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test.test();<span class="comment">//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test.test();</code> 时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test test = new Test();</code> 时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--</span><br></pre></td></tr></table></figure><p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 </p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合概览</title>
      <link href="2020/09/01/2020-09-01-%E9%9B%86%E5%90%88/"/>
      <url>2020/09/01/2020-09-01-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/collection-summary.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/collection-summary.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Java集合"></p><h3 id="常用集合的分类"><a href="#常用集合的分类" class="headerlink" title="常用集合的分类"></a>常用集合的分类</h3><p><strong>Collection</strong> 接口的接口 对象的集合（单列集合）<br>├——-<strong>List</strong> 接口：元素按进入先后有序保存，可重复<br>│—————-├ <strong>LinkedList</strong> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ <strong>ArrayList</strong> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-└ <strong>Vector</strong> 接口实现类 数组， 同步， 线程安全<br>│ ———————-└ <strong>Stack</strong> 是Vector类的实现类<br>└——-<strong>Set</strong> 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-└<strong>HashSet</strong> 使用hash表（数组）存储元素<br>│————————└ <strong>LinkedHashSet</strong> 链表维护元素的插入次序<br>└ —————-<strong>TreeSet</strong> 底层实现为二叉树，元素排好序</p><p><strong>Map</strong> 接口 键值对的集合 （双列集合）<br>├———<strong>Hashtable</strong> 接口实现类， 同步， 线程安全<br>├———<strong>HashMap</strong> 接口实现类 ，没有同步， 线程不安全-<br>│—————–├ <strong>LinkedHashMap</strong> 双向链表和哈希表实现<br>│—————–└ <strong>WeakHashMap</strong><br>├ ——–<strong>TreeMap</strong> 红黑树对所有的key进行排序<br>└———<strong>IdentifyHashMap</strong></p><h3 id="Collection子接口List"><a href="#Collection子接口List" class="headerlink" title="Collection子接口List"></a>Collection子接口List</h3><blockquote><p><code>List</code>:存储的元素是有序的，可重复的。</p></blockquote><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><img src="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/ArrayList-diagram.png" class="lazyload" data-srcset="https://blog-image-1301262590.cos.ap-nanjing.myqcloud.com/ArrayList-diagram.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ArrayList继承关系图"></p><blockquote><p>实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</p></blockquote><p>ArrayList三个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span><span class="comment">//构造一个具有指定初始容量的空列表。    </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span>      <span class="comment">//默认构造一个初始容量为10的空列表。    </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span><span class="comment">//构造一个包含指定 collection 的元素的列表(深拷贝)</span></span></span><br></pre></td></tr></table></figure><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><h3 id="Collection子接口Set"><a href="#Collection子接口Set" class="headerlink" title="Collection子接口Set"></a>Collection子接口Set</h3><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奋斗者的人生才是幸福的人生!</title>
      <link href="2020/06/16/2020-06-16-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B/"/>
      <url>2020/06/16/2020-06-16-%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">生活就像一面镜子</span><br><span class="line"></span><br><span class="line">你赠予它微笑，它回馈你美貌 </span><br><span class="line"></span><br><span class="line">你充斥着怒气，它回馈你丑陋</span><br><span class="line"></span><br><span class="line">当生活像一首歌那样</span><br><span class="line"></span><br><span class="line">轻快流畅时</span><br><span class="line"></span><br><span class="line">笑颜常开乃易事</span><br><span class="line"></span><br><span class="line">而在面对挫折时仍能乐观</span><br><span class="line"></span><br><span class="line">希望就像灿烂的阳光</span><br><span class="line"></span><br><span class="line">带着坚定的信念</span><br><span class="line"></span><br><span class="line">突破重重云层</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 新生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql简笔</title>
      <link href="2017/10/24/2017-10-24-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2017/10/24/2017-10-24-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><pre><code>    net start mysql    net stop mysql</code></pre><p>​<br><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/%E5%90%AF%E5%8A%A8.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/%E5%90%AF%E5%8A%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/%E5%81%9C%E6%AD%A2.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/%E5%81%9C%E6%AD%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h2><blockquote><p>输入用户名密码。</p></blockquote><pre><code>        mysql -u 用户名 -p        如：mysql -u root -p</code></pre><p>效果如下：</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/mysql%E8%BF%9B%E5%85%A5.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/mysql%E8%BF%9B%E5%85%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="查看基本命令"><a href="#查看基本命令" class="headerlink" title="查看基本命令"></a>查看基本命令</h3><blockquote><p>每条命令结束后一定要加分号</p></blockquote><p>1.show databases; 查看数据库</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/showdatabases.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/showdatabases.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>2.use 数据库;  选择数据库并使用它</p><blockquote><p>这里我提前新建好了数据库s_t，建库的方法下面持续会讲。</p></blockquote><p>如：</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/use.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/use.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>3.show tables; 查看use的数据库的tables（表）;</p><p>我这里有下面3个表：</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/showtables.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/showtables.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>4.select * from 表名; 查看某个表</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/select.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/select.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>5.show columns from 表名; 查看某个表中所有字段</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/columns.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/columns.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>以上几个命令是必须掌握的查看命令</strong></p><h3 id="SQL语句对MySQL的操作"><a href="#SQL语句对MySQL的操作" class="headerlink" title="SQL语句对MySQL的操作"></a>SQL语句对MySQL的操作</h3><blockquote><p>这里我提前新建好了数据库s_t，建库的方法下面持续会讲。库中有3个表各个表的数据如下：</p></blockquote><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/Student.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/Student.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="student"></p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/couse.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/couse.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="course"></p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/sc.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/sc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="sc"></p><ol><li><p>基本表的定义、删除、与修（略）</p></li><li><p>sql基本了解(注：sql语言不区分大小写）</p></li></ol><h2 id="SQL语句之数据查询"><a href="#SQL语句之数据查询" class="headerlink" title="SQL语句之数据查询"></a>SQL语句之数据查询</h2><blockquote><p>基本结构如下：<br>SELECT …<br>FROM …<br>WHERE …</p></blockquote><p>一、 单表查询</p><p>1.查询全体学生的学号与姓名。</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/Snoname.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/Snoname.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>2.查询出生年月日。</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/2017.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/2017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>3.消除取值重复的行</p><blockquote><p>关键词<code>distinct</code></p></blockquote><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Mysql/distinct.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Mysql/distinct.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>4.聚集函数</p><p><strong>where子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having子句。</strong></p><h2 id="SQL语句之数据更新"><a href="#SQL语句之数据更新" class="headerlink" title="SQL语句之数据更新"></a>SQL语句之数据更新</h2><p>一、插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT</span><br><span class="line">INTO &lt;表名&gt; (&lt;属性列1&gt;,&lt;属性列2&gt;,...)</span><br><span class="line">VALUES (&#39;常量1&#39;,&#39;常量2&#39;,...)</span><br></pre></td></tr></table></figure><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><blockquote><p>如果想更好的了解推荐以下视频</p></blockquote><p><a href="http://www.imooc.com/learn/122"><strong>与MySQL的零距离接触</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2017/10/24/2017-10-24-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2017/10/24/2017-10-24-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是动态规划（DP）？"><a href="#什么是动态规划（DP）？" class="headerlink" title="什么是动态规划（DP）？"></a>什么是动态规划（DP）？</h2><blockquote><p> DP起源于运筹学，是求解决策过程最优化的数学方法，它一种是将多阶段过程转化为一系列单阶段问题，再利用各阶段之间的关系，逐个求解的方法。即动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要<em>多项式时间复杂度</em>，因此它比回溯法、暴力法等要快许多。</p></blockquote><h2 id="动态规划干什么用？"><a href="#动态规划干什么用？" class="headerlink" title="动态规划干什么用？"></a>动态规划干什么用？</h2><blockquote><p>求解决策过程最优化。因此动态规划算法通常用于求解具有某种最优性质的问题。</p></blockquote><p>通常可按以下4个步骤设计：</p><ol><li><p>找出最优解的性质，并刻画其结构特征。</p></li><li><p>递归地定义最优值。</p></li><li><p>以<em>自底向上</em>的方式计算出最优解。</p></li><li><p>根据计算最优值时得到的信息，构造最优解。</p></li></ol><p>动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。</p><pre><code>    如：    线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；    区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；    树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；    背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶 等；</code></pre><h3 id="经典例题01背包问题"><a href="#经典例题01背包问题" class="headerlink" title="经典例题01背包问题"></a>经典例题01背包问题</h3><blockquote><p>问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p></blockquote><p>如：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p><p>本题特点是：每种物品仅有一件，可以选择放或不放。</p><p><strong>F[i，j]表示在前i个物品中能够装入容量为j的背包中的最大价值。同时设v[i]、w[i]分别为第i个物品的价值和重量，v为背包的容量。</strong></p><p>其状态转移方程便是：                        </p><pre><code>    F[i, v] = maxf&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125;</code></pre><h3 id="二维0-1背包问题"><a href="#二维0-1背包问题" class="headerlink" title="二维0-1背包问题"></a>二维0-1背包问题</h3><blockquote><pre><code>        给定n种物品和一个背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为c，容积为d。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品只有两个选择：装入或不装入，且不能重复装入。        </code></pre></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twobage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxx</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= b)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] weight = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span> &#125;; <span class="comment">// 物品重量</span></span><br><span class="line"><span class="keyword">int</span>[] val = &#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;; <span class="comment">// 物品价值</span></span><br><span class="line"><span class="keyword">int</span>[] b = &#123; <span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">30</span>; <span class="comment">// 背包容积</span></span><br><span class="line"><span class="keyword">int</span> p, q, i, m = <span class="number">10</span>; <span class="comment">// 背包容量</span></span><br><span class="line"><span class="keyword">int</span> n = val.length; <span class="comment">// 物品个数</span></span><br><span class="line"><span class="keyword">int</span>[][][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>][z + <span class="number">1</span>]; <span class="comment">// f[i][x][y]表示只允许装前i种物品，背包总重不超过x,物品总体积不超过y时，背包最大价值</span></span><br><span class="line"><span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">//下标加1对应物品下标，其值为0代表不放，为1代表放</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">0</span>; p &lt;= m; p++)</span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">0</span>; q &lt;= z; q++)</span><br><span class="line">f[<span class="number">0</span>][p][q] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= m; p++)</span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">1</span>; q &lt;= z; q++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; weight[i - <span class="number">1</span>] || q &lt; b[i - <span class="number">1</span>]) &#123;</span><br><span class="line">f[i][p][q] = f[i - <span class="number">1</span>][p][q];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">f[i][p][q] = maxx(f[i - <span class="number">1</span>][p][q], f[i - <span class="number">1</span>][p - weight[i - <span class="number">1</span>]][q - b[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p = m;</span><br><span class="line">q = z;</span><br><span class="line"><span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i][p][q] &gt; f[i - <span class="number">1</span>][p][q]) &#123;</span><br><span class="line">path[i] = <span class="number">1</span>;</span><br><span class="line">p = p - weight[i-<span class="number">1</span>];</span><br><span class="line">q = q - b[i-<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">path[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;path值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">System.out.print(path[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(<span class="string">&quot;放入的物品为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(path[i]==<span class="number">1</span>)</span><br><span class="line">System.out.print(i-<span class="number">1</span>+<span class="string">&quot;号  &quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (path[i] == <span class="number">1</span>)</span><br><span class="line">r += val[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r += <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;最大价值为：&quot;</span>+r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多背包问题可以参考<a href="https://wenku.baidu.com/view/4d68b68fbceb19e8b8f6bacd.html">背包九讲</a></p><hr><h2 id="动态规划算法的基本要素"><a href="#动态规划算法的基本要素" class="headerlink" title="动态规划算法的基本要素"></a>动态规划算法的基本要素</h2><h3 id="1-最优子结构"><a href="#1-最优子结构" class="headerlink" title="1. 最优子结构"></a>1. 最优子结构</h3><h3 id="2-重叠子问题"><a href="#2-重叠子问题" class="headerlink" title="2. 重叠子问题"></a>2. 重叠子问题</h3><h3 id="3-边界"><a href="#3-边界" class="headerlink" title="3. 边界"></a>3. 边界</h3><h3 id="4-子问题独立"><a href="#4-子问题独立" class="headerlink" title="4. 子问题独立"></a>4. 子问题独立</h3><h3 id="5-备忘录方法"><a href="#5-备忘录方法" class="headerlink" title="5. 备忘录方法"></a>5. 备忘录方法</h3><p>这里举个简单的例题：动态规划入门-数字三角形</p><pre><code>    Description    7    3   8    8   1   0    2   7   4   4    4   5   2   6   5    在上面的数字三角形中寻找一条从顶部到底边的路径，使得    路径上所经过的数字之和最大。路径上的每一步都只能往左下或    右下走。只需要求出这个最大和即可，不必给出具体路径。    三角形的行数大于1小于等于100，数字为 0 - 99    输入格式：    5 //三角形行数。下面是三角形    7    3 8    8 1 0    2 7 4 4    4 5 2 6 5    要求输出最大和</code></pre><p>​         </p><pre><code>    Sample Output    30    代码：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangle</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 测试数据：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment">8 1 0</span></span><br><span class="line"><span class="comment">2 7 4 4</span></span><br><span class="line"><span class="comment">4 5 2 6 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;请输入行数：&quot;</span>);</span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] a=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span>[][] path=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pmax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;i++) &#123;</span><br><span class="line">a[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line">a[i][j]=(<span class="keyword">int</span>)sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出测试数组</span></span><br><span class="line"><span class="comment">/*for(int i=0;i&lt;=n+1;i++) &#123;</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;i+1;j++) &#123;</span></span><br><span class="line"><span class="comment">System.out.print(a[i][j]+&quot; &quot;);</span></span><br><span class="line"><span class="comment">&#125;System.out.println();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt; i;j++) &#123;</span><br><span class="line">path[i][j]=max(path[i-<span class="number">1</span>][j],path[i-<span class="number">1</span>][j-<span class="number">1</span>])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//输出子问题值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt; i;j++) &#123;</span><br><span class="line">System.out.print(path[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pmax &lt; path[i][j]) &#123;</span><br><span class="line">                    pmax = path[i][j];<span class="comment">//算出最大值</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;最大值为：&quot;</span>+pmax);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多感悟，如果还有下次，再见<del>~</del>    </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机</title>
      <link href="2017/10/21/2017-10-21-T2%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>2017/10/21/2017-10-21-T2%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="实验三思考题："><a href="#实验三思考题：" class="headerlink" title="实验三思考题："></a>实验三思考题：</h2><blockquote><p>若系统时钟频率为12MHz，编写软件实现：按一下K键，产生一次外部中断1中断信号，启动T2定时，使P1.1输出周期为2秒的方波。</p></blockquote><hr><p>定时器T2,<strong>reg52.h</strong>没有T2MOD寄存器,<strong>regx55.h</strong>有T2MOD寄存器而且sbit已经定义。<br>因此头文件用reg55.h。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码:"></a>参考代码:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;regx55.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned int</span><br><span class="line">sbit P11&#x3D;P1^1;</span><br><span class="line">uchar num&#x3D;0;</span><br><span class="line">void main()&#123;</span><br><span class="line">T2MOD&#x3D;0x00;</span><br><span class="line">TH2&#x3D;(65536-50000)&#x2F;256;</span><br><span class="line">TL2&#x3D;(65536-50000)%256;</span><br><span class="line">RCAP2H&#x3D;(65536-50000)&#x2F;256;</span><br><span class="line">RCAP2L&#x3D;(65536-50000)%256;</span><br><span class="line">IE&#x3D;0xa4;</span><br><span class="line">while(1)&#123;</span><br><span class="line"> if(TF2)&#123;</span><br><span class="line"> num++;</span><br><span class="line"> TF2&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">if(num&#x3D;&#x3D;20)&#123;</span><br><span class="line"> P11&#x3D;~P11;</span><br><span class="line">num&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void INTer1() interrupt 2</span><br><span class="line">&#123;</span><br><span class="line">TR2&#x3D;1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为简单，所以没有注释。</p><hr><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="http://aaa-1255318572.coscd.myqcloud.com/as.png" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/as.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><a href="http://aaa-1255318572.coscd.myqcloud.com/%E5%AE%9E%E9%AA%8C%E4%B8%89%E6%80%9D%E8%80%83%E9%A2%98.7z">代码工程及仿真</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 大学时光 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll</title>
      <link href="2017/10/21/2017-10-21-jekyll/"/>
      <url>2017/10/21/2017-10-21-jekyll/</url>
      
        <content type="html"><![CDATA[<h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><blockquote><p>Jekyll网站的目录结构。</p></blockquote><hr><pre><code>.├── _config.yml├── _data|   └── members.yml├── _drafts|   ├── begin-with-the-crazy-ideas.md|   └── on-simplicity-in-technology.md├── _includes|   ├── footer.html|   └── header.html├── _layouts|   ├── default.html|   └── post.html├── _posts|   ├── 2007-10-29-why-every-programmer-should-play-nethack.md|   └── 2009-04-26-barcamp-boston-4-roundup.md├── _sass|   ├── _base.scss|   └── _layout.scss├── _site├── .jekyll-metadata└── index.html # can also be an &#39;index.md&#39; with valid YAML Frontmatter</code></pre><hr><h2 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h2><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p><a href="https://jekyllrb.com/docs/structure/">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 暂未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归的时间复杂度</title>
      <link href="2017/10/21/2017-10-21-%E9%80%92%E5%BD%92%E6%A0%91/"/>
      <url>2017/10/21/2017-10-21-%E9%80%92%E5%BD%92%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Master定理"><a href="#Master定理" class="headerlink" title="Master定理"></a>Master定理</h2><blockquote><p>有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p></blockquote><p>设常数a &gt;= 1，b &gt; 1，f(n)为函数，T(n)为非负整数，T(n) = a T(n / b) + f(n)，则有：</p><p><img src="http://aaa-1255318572.coscd.myqcloud.com/Master.PNG" class="lazyload" data-srcset="http://aaa-1255318572.coscd.myqcloud.com/Master.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><h2 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a><a href="http://blog.csdn.net/u012593447/article/details/47168335">递归树</a></h2><p>没事间写QAQ………</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Rose</title>
      <link href="2017/10/20/2017-10-20-rose/"/>
      <url>2017/10/20/2017-10-20-rose/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Rose"><a href="#The-Rose" class="headerlink" title="The Rose"></a>The Rose</h2><pre><code>                        Some say love it is a river                        That drowns the tender reed                        Some say love it is a razor                        That leaves your soul to bleed                        Some say love it is a hunger                        An endless aching need                        I say love it is a flower                        And you , its only seed                        It&#39;s the heart afraid of breaking                        That never learns to dance                        It&#39;s the dream afraid of waking                        That never takes the chance                        It&#39;s the one who won&#39;t be taken                        Who cannot seem to give                        And the soul afraid of dying                        That never learns to live                        When the night has been too lonely                        And the road has been too long                        And you think that love is only                        For the lucky and the strong                        Just remember in the winter                        Far beneath the bitter snows                        Lies the seed that with the sun&#39;s love                        In the spring becomes the rose</code></pre>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如生活欺骗了你</title>
      <link href="2017/10/20/2017-10-20-%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/"/>
      <url>2017/10/20/2017-10-20-%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="假如生活欺骗了你"><a href="#假如生活欺骗了你" class="headerlink" title="假如生活欺骗了你"></a>假如生活欺骗了你</h2><blockquote><p>《假如生活欺骗了你》是俄国诗人普希金于1825年流放南俄敖德萨同当地总督发生冲突后，被押送到其父亲的领地米哈伊洛夫斯科耶村幽禁期间创作的一首诗歌。诗歌全文表述了一种积极乐观而坚强的人生态度，并且因它亲切和蔼的口气让许多人把它记于自己的笔记本上，成为了激励自己勇往直前，永不放弃的座右铭。</p></blockquote><h3 id="If-by-Life-You-Were-Deceived"><a href="#If-by-Life-You-Were-Deceived" class="headerlink" title="If by Life You Were Deceived"></a>If by Life You Were Deceived</h3><pre><code>                        If by life you were deceived,                         Don&#39;t be dismal,don&#39;t be wild!                        In the day of grief,be mild:                        Merry days will come,believe.                        Heart is living in tomorrow;                        Present is dejected here:                        In a moment,passes sorrow;                        That which passes will be dear.</code></pre><hr><h4 id="假如生活欺骗了你-1"><a href="#假如生活欺骗了你-1" class="headerlink" title="假如生活欺骗了你"></a>假如生活欺骗了你</h4><pre><code>                        假如生活欺骗了你，                        不要悲伤，不要心急！                        忧郁的日子里须要镇静：                        相信吧，快乐的日子将会来临！                        心儿永远向往着未来；                        现在却常是忧郁。                        一切都是瞬息，一切都将会过去；                        而那过去了的，就会成为亲切的怀恋。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,world!</title>
      <link href="2017/10/19/2017-10-19-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/"/>
      <url>2017/10/19/2017-10-19-%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Hey"><a href="#Hey" class="headerlink" title="Hey"></a>Hey</h2><blockquote><p>Hello World 中文意思是『世界，你好』。因为《The C Programme Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。</p></blockquote><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package text1;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.printf(&quot;hello,world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VB"><a href="#VB" class="headerlink" title="VB"></a>VB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module MainFrm</span><br><span class="line">    Sub Main()</span><br><span class="line">        System.Console.WriteLine(&quot;Hello, World!&quot;)</span><br><span class="line">    End Sub</span><br><span class="line">End Module</span><br></pre></td></tr></table></figure><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def hello()  </span><br><span class="line">  return &quot;Hello , World&quot;    </span><br><span class="line">end  </span><br></pre></td></tr></table></figure><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;flush;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 新生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
